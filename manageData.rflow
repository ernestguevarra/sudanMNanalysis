<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rflow [
<!ENTITY lt "&#38;#60;">
<!ENTITY gt "&#62;">
<!ENTITY amp "&#38;#38;">
<!ENTITY apos "&#39;">
<!ENTITY quot "&#34;">
]>
<rflow>
	<graph version="0.8" width="1093" height="437" locationtype="a" offsetx="10" offsety="-19">
		<setting>
			<entry key="USE_GRID">true</entry>
			<entry key="FOLDER">manageData</entry>
			<entry key="GRID_DISTANCE2">10</entry>
		</setting>
<properties>
<v key="packages"/>
</properties>
		<node id="0" date="1590573116525" uid="e3791151bdf45128" x="240" y="150">
			<command>## Code here to censor data that canot be used and to save &apos;mnData&apos; to disk

## Check data for missing values for psu
table(is.na(mnData$psu) | !mnData$psu %in% psuData$psu)

## 962 rows of data with NA value for PSU or with PSU not in the survey data. 
## There is no known way to determine PSU through other data. These data will
## be removed/censored

## Remove data with missing PSUs or PSUs not mathcing 
mnData &lt;- mnData[!is.na(mnData$psu), ]
mnData &lt;- mnData[mnData$psu %in% psuData$psu, ]

## Check for data with missing locality or with localityID not in survey data
table(is.na(mnData$localityID) | !mnData$localityID %in% psuData$locality)

## No missing locality information

## Check for data with missing state or with stateID not in survey data
table(is.na(mnData$stateID) | !mnData$stateID %in% psuData$state)

## No missing state information

## Check for data that has none of the micronutrient data
table(apply(is.na(mnData[ c(&quot;hb&quot;, &quot;calcium&quot;, &quot;crp&quot;, &quot;ferritin&quot;, &quot;iodine&quot;)]), MARGIN = 1, FUN = all))

## 25 rows of data have no information on any micronutrients. These rows will be
## removed
mnData &lt;- mnData[!apply(is.na(mnData[ c(&quot;hb&quot;, &quot;calcium&quot;, &quot;crp&quot;, &quot;ferritin&quot;, &quot;iodine&quot;)]), MARGIN = 1, FUN = all), ]

## Remove records with no age group
mnData &lt;- mnData[!is.na(mnData$ageGrp), ]

## Check MN values - use NiPN for this purpose

## Check micronutrient values for haemoglobin (hb)
##   - hb measured in g/dL

hist(mnData$hb) 

## long upper tail - most likely a few very high values upwards to 100 - check

summary(mnData$hb)

## There is one value as high as 106 which is not a likely value for hb at units of g/dL
## Likely that this an encoding issue where the decimal point was not entered
## Most likely safe to convert this value to 10.6

mnData$hb[mnData$hb == 106] &lt;- 10.6

## Check hb data again
hist(mnData$hb)
summary(mnData$hb)

## Still some high values of 27.6 for a woman age 27 years old; and
## 25 for a child 25 months old and low values of 2

mnData[mnData$hb == 27.6 &amp; !is.na(mnData$hb), ]
mnData[mnData$hb == 25 &amp; !is.na(mnData$hb), ]
mnData[mnData$hb == 2 &amp; !is.na(mnData$hb), ]

## Extremely unlikely as this level of Hb is more commonly seen in 
## newborns or those with chronic diseases (e.g. COPD) or someone
## who is actively hemolysing or someone who has rare genetic
## conditions such as polycythemia vera
##
## Possible that this is an encoding issue where 2 was typed instead
## of a 1 at the bebinning to give a value of 17.6. A women with this
## Hb is still considered on the higher end but is more compatible
## with someone who is still ambulant and not in distress. The other
## option will be to censor these hb values by making them NAs

## Check outliers using outlierUV

mnData[outliersUV(mnData$hb), ]

## 311 records detected as outliers but these seem to be plausible values
## Keep these valules

## Check micronutrient values for calcium (units mg/dL)

hist(mnData$calcium)
summary(mnData$calcium)

## Check with outliersUV

mnData[outliersUV(mnData$calcium), ]

## 102 records detected as outliers by outliersUV; these all still seem to be plausible values

## calcium looks OK with no note of any extreme values.
## Consider keeping calcium as is

## Check CRP (mg/L)

hist(mnData$crp)
summary(mnData$crp)

## check with outliersUV

mnData[outliersUV(mnData$crp), ]

## 783 records have been flagged as outliers. However, these are higher
## than normal CRP which can be expected in a setting where acute infections
## can be quite common

## There are a few values of CRP above 100 which can still be
## feasible/plausible values. No reason to change or censor
## these values

## Check ferritin (ng/mL)

hist(mnData$ferritin)
summary(mnData$ferritin)

## Check with outliersUV

mnData[outliersUV(mnData$ferritin), ]
table(outliersUV(mnData$ferritin))

## 1003 records flagges as outliers; However, these are all still plausible values

## Thare a few values above 400 but these are plausible values.
## Keep these values.


## Check iodine (microgram / L)

hist(mnData$iodine)
summary(mnData$iodine)

mnData[outliersUV(mnData$iodine), ]
table(outliersUV(mnData$iodine))

## 122 values flagged as outliers by outliersUV but these are still
## plausible values for iodine

## Urinary iodine values are plausible. Keep


</command>
			<property title="censor"/>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="1" date="1591264787811" uid="7206ddf0e9599e2b" x="330" y="150">
			<command>## Save data
save(list = ls(), file = &quot;work.Rdata&quot;)</command>
			<property title="Save clean dataset" shape="INOUT"/>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="2" date="1591267275743" uid="4e452689fbba3470" x="530" y="400">
			<command>## Read results data
stateResults &lt;- read.csv(&quot;_byStatesMNresults.csv&quot;, stringsAsFactors = FALSE)
statePops &lt;- read.xlsx(&quot;_statePops.xlsx&quot;, sheet = 1)
statePops$state &lt;- str_remove_all(string = statePops$state, pattern = &quot; State&quot;)

indicatorBase &lt;- stateResults[stateResults$State == &quot;Northern&quot;, &quot;Indicator&quot;]
locNames &lt;- read.csv(&quot;data/locNames.csv&quot;, stringsAsFactors = FALSE)

## Accumulator for pooled results
nationalResults &lt;- NULL

## Cycle through states
for(i in 1:length(indicatorBase))
{
  estimates &lt;- standardErrors &lt;- weights &lt;- NULL
  for(j in unique(stateResults$State)) 
  {
    ## Get estimates for current indicator, SE, and population weight in current state
    estimates &lt;- c(estimates, stateResults[stateResults$State == j, &quot;estimate&quot;][i])
    standardErrors &lt;- c(standardErrors, stateResults[stateResults$State == j, &quot;sd&quot;][i])
    ## Get weight for state
    weights &lt;- c(weights, statePops$pop[statePops$state == j])
  }
  pooledEstimate &lt;- sum(estimates * weights, na.rm = TRUE) / sum(weights, na.rm = TRUE)
  pooledSE  &lt;- sqrt(sum(standardErrors^2 * weights / sum(weights, na.rm = TRUE), na.rm = TRUE))
    
  ## Correct for LCL less than 0
  pooledLCL &lt;- pooledEstimate - 1.96 * pooledSE
  #pooledLCL &lt;- ifelse(pooledLCL &lt; 0 &amp; pooledEstimate &gt; 0.0001, 0.0001, pooledLCL)
  #pooledLCL &lt;- ifelse(pooledLCL &lt; 0 &amp; pooledEstimate &gt;= 0 &amp; pooledEstimate &lt; 0.0001, 0, pooledLCL)

  ## Correct for UCL greater than 1
  pooledUCL &lt;- pooledEstimate + 1.96 * pooledSE
  #pooledUCL &lt;- ifelse(pooledUCL &gt; 1, 0.9999, pooledUCL)

  ## Convert proportion estimates to percentages and round off estimates to 2 decimal places
  #pooledEstimate &lt;- round(pooledEstimate * 100, digits = 2)
  #pooledLCL &lt;- round(pooledLCL * 100, digits = 2)
  #pooledUCL &lt;- round(pooledUCL * 100, digits = 2)
    
  ## Make a results row
  resultRow &lt;- c(pooledEstimate, pooledLCL, pooledUCL)
  nationalResults &lt;- rbind(nationalResults, resultRow)
}

nationalResults &lt;- data.frame(indicatorBase, nationalResults, stringsAsFactors = FALSE)
names(nationalResults) &lt;- c(&quot;Indicator&quot;, &quot;Estimate&quot;, &quot;LCL&quot;, &quot;UCL&quot;)
row.names(nationalResults) &lt;- 1:nrow(nationalResults)

nationalResults$LCL &lt;- ifelse(nationalResults$LCL &lt; 0, 0.0001, nationalResults$LCL)

write.csv(nationalResults, &quot;_nationalResults.csv&quot;, row.names = FALSE)

nationalResults[!str_detect(nationalResults$Indicator, pattern = &quot;Median&quot;), c(&quot;Estimate&quot;, &quot;LCL&quot;, &quot;UCL&quot;)] &lt;- round(nationalResults[!str_detect(nationalResults$Indicator, pattern = &quot;Median&quot;), c(&quot;Estimate&quot;, &quot;LCL&quot;, &quot;UCL&quot;)] * 100, digits = 2)
nationalResults[str_detect(nationalResults$Indicator, pattern = &quot;Median&quot;), c(&quot;Estimate&quot;, &quot;LCL&quot;, &quot;UCL&quot;)] &lt;- round(nationalResults[str_detect(nationalResults$Indicator, pattern = &quot;Median&quot;), c(&quot;Estimate&quot;, &quot;LCL&quot;, &quot;UCL&quot;)], digits = 2)

write.xlsx(x = nationalResults, file = &quot;_nationalResults.xlsx&quot;)

</command>
			<property title="National Results" shape="MODEL"/>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="3" date="1590739211142" uid="5eec23be8f37c3ba" x="60" y="240">
			<command>load(&quot;work.Rdata&quot;)</command>
			<property title="Load raw data" shape="INOUT"/>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="4" date="1591267014593" uid="ecc1d55845a8fb71" x="250" y="470">
			<command>## Select states to bootstrap
STATES &lt;- c(6, 12, 18)

## Bootstrap anaemia indicators ################################################
  
## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)
  
## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))
  
## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])
  
## indicator name vector
params &lt;- c(&quot;adjHb&quot;, &quot;AN0&quot;, &quot;AN1&quot;, &quot;AN2&quot;, &quot;AN3&quot;)
  
## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(STATES) * 3, 
                            byrow = TRUE))
  
bootDFnames &lt;- NULL
  
for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}
  
## rename bootDF
names(bootDF) &lt;- bootDFnames
  
## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}
  
## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)
  
## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)
  
## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)
  
## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AN0&quot;, &quot;Any anaemia&quot;, 
                        ifelse(yy[ , 3] == &quot;AN1&quot;, &quot;Mild anaemia&quot;,
                        ifelse(yy[ , 3] == &quot;AN2&quot;, &quot;Moderate anaemia&quot;, 
                               ifelse(yy[ , 3] == &quot;AN3&quot;, &quot;Severe anaemia&quot;, 
                                      &quot;Median adjusted serum haemoglobin concentration (g/dL)&quot;))))

anaemiaResults6 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)

## Bootstrap calcium indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;calcium&quot;, &quot;CA1&quot;, &quot;CA2&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), 
                                                 bootMedian, 
                                                 bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;CA1&quot;, &quot;Hypocalcaemia&quot;,
                        ifelse(yy[ , 3] == &quot;CA2&quot;, &quot;Hypercalcaemia&quot;, 
                               &quot;Median serum calcium concentration (mg/dL)&quot;))

calciumResults6  &lt;- data.frame(State = yy[ , 1],
                               Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                               xx,
                               row.names = NULL,
                               stringsAsFactors = FALSE)

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;crp&quot;, &quot;AI&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AI&quot;, &quot;Acute inflammation&quot;, 
                               &quot;Median serum c-reactive protein concentration (mg/L)&quot;)

inflammationResults6 &lt;- data.frame(State = yy[ , 1],
                                   Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                                   xx,
                                   row.names = NULL,
                                   stringsAsFactors = FALSE)

## Bootstrap anaemia indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- with(subDF, {
  ifelse(pregnant == 1, &quot;Pregnant&quot;,
    ifelse(pregnant == 2 &amp; lactating == 2, &quot;Non-pregnant non-lactating&quot;,
      ifelse(pregnant == 2 &amp; lactating == 1, &quot;Non-pregnant lactating&quot;, NA)))
})

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;iodine&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

iodineResults6&lt;- data.frame(State = yy[ , 1],
                             Indicator = paste(yy[ , 2], &quot;Median urinary iodine concentration (microgram/L)&quot;, sep = &quot;: &quot;),
                             xx,
                             row.names = NULL,
                             stringsAsFactors = FALSE)

## Bootstrap iron indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;IR1&quot;, &quot;IR2&quot;, &quot;IDA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(locNames$locality[locNames$stateID %in% STATES]) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in unique(locNames$locality[locNames$state == i])) {
    for(k in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
      for(l in params) {
        bootDFnames &lt;- c(bootDFnames, paste(i, j, k, l, sep = &quot;_&quot;))
      }
    }
  }
}

names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$localityID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$localityID == i])
  ## Get current locality name
  currentLocalityName &lt;- unique(locNames$locality[locNames$localityID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, localityID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      cat(&quot;\n&quot;, 
          currentStateName, &quot; - &quot;, 
          currentLocalityName, &quot; - &quot;, 
          j, &quot; - &quot;,
          k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = bootClassic, 
                              params = k,
                              outputColumns = paste(currentStateName,
                                                    currentLocalityName,
                                                    j,
                                                    k,
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, currentLocalityName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename rows
#row.names(xx) &lt;- 1:nrow(xx)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 4] == &quot;IR1&quot;, &quot;Iron deficiency&quot;,
                   ifelse(yy[ , 4] == &quot;IR2&quot;, &quot;Iron overload&quot;, &quot;Iron deficiency anaemia&quot;))

ironResults6 &lt;- data.frame(State = yy[ , 1],
                           Locality = yy[ , 2],
                           Indicator = paste(yy[ , 3], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

ironResults6 &lt;- ironResults6[ironResults6$Indicator != &quot;Child: Iron overload&quot;, ]

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;retinol&quot;, &quot;VA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VA&quot;, &quot;Vitamin A deficiency&quot;, 
                               &quot;Median serum retinol concentration (mg/L)&quot;)

retinolResults6 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;vitd&quot;, &quot;VD&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VD&quot;, &quot;Vitamin D deficiency&quot;, 
                               &quot;Median serum 25-hydroxyvitamin D3 concentration (mg/L)&quot;)

vitdResults6 &lt;- data.frame(State = yy[ , 1],
                           Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

## Combine all
allResults6 &lt;- data.frame(
  rbind(anaemiaResults6, inflammationResults6, ironResults6,
        calciumResults6, iodineResults6, retinolResults6, vitdResults6), stringsAsFactors = FALSE
)

## Save
save(allResults6, file = &quot;resultsSet6.Rdata&quot;)

## Clean-up
rm(allResults6, anaemiaResults6, inflammationResults6, ironResults6, calciumResults6, iodineResults6, retinolResults6, vitdResults6)

</command>
			<property title="Bootstrap Set 6" shape="MODEL"/>
			<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
				<subflow>
					<graph version="0.8" width="920" height="245" locationtype="a" offsetx="100" offsety="50">
						<node id="5" date="1591266428093" uid="a669b956383fb6f3" x="250" y="0">
							<command>## Bootstrap iron indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;IR1&quot;, &quot;IR2&quot;, &quot;IDA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(locNames$locality[locNames$stateID %in% STATES]) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in unique(locNames$locality[locNames$state == i])) {
    for(k in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
      for(l in params) {
        bootDFnames &lt;- c(bootDFnames, paste(i, j, k, l, sep = &quot;_&quot;))
      }
    }
  }
}

names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$localityID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$localityID == i])
  ## Get current locality name
  currentLocalityName &lt;- unique(locNames$locality[locNames$localityID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, localityID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      cat(&quot;\n&quot;, 
          currentStateName, &quot; - &quot;, 
          currentLocalityName, &quot; - &quot;, 
          j, &quot; - &quot;,
          k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = bootClassic, 
                              params = k,
                              outputColumns = paste(currentStateName,
                                                    currentLocalityName,
                                                    j,
                                                    k,
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, currentLocalityName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename rows
#row.names(xx) &lt;- 1:nrow(xx)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 4] == &quot;IR1&quot;, &quot;Iron deficiency&quot;,
                   ifelse(yy[ , 4] == &quot;IR2&quot;, &quot;Iron overload&quot;, &quot;Iron deficiency anaemia&quot;))

ironResults6 &lt;- data.frame(State = yy[ , 1],
                           Locality = yy[ , 2],
                           Indicator = paste(yy[ , 3], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

ironResults6 &lt;- ironResults6[ironResults6$Indicator != &quot;Child: Iron overload&quot;, ]
</command>
							<property title="Iron" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="6" date="1591269365199" uid="60b01a314d67d26a" x="250" y="90">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;retinol&quot;, &quot;VA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VA&quot;, &quot;Vitamin A deficiency&quot;, 
                               &quot;Median serum retinol concentration (mg/L)&quot;)

retinolResults6 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)
</command>
							<property title="Retinol" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="7" date="1591266428110" uid="1fa3045f7a65bea3" x="0" y="0">
							<command>## Select states to bootstrap
STATES &lt;- c(6, 12, 18)</command>
							<property title="Setup Set 6" shape="INPUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="8" date="1591267014593" uid="2ccb5abba48ebc2b" x="480" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">out</entry>
							</option>
						</node>
						<node id="9" date="1591269365205" uid="a899167989988d32" x="410" y="0">
							<command>## Combine all
allResults6 &lt;- data.frame(
  rbind(anaemiaResults6, inflammationResults6, ironResults6,
        calciumResults6, iodineResults6, retinolResults6, vitdResults6), stringsAsFactors = FALSE
)

## Save
save(allResults6, file = &quot;resultsSet6.Rdata&quot;)

## Clean-up
rm(allResults6, anaemiaResults6, inflammationResults6, ironResults6, calciumResults6, iodineResults6, retinolResults6, vitdResults6)

</command>
							<property title="Combine results" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="10" date="1591267014593" uid="b3269c103f205329" x="-80" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">in</entry>
							</option>
						</node>
						<node id="11" date="1591266428117" uid="f28c186596521fa" x="170" y="0">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;crp&quot;, &quot;AI&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AI&quot;, &quot;Acute inflammation&quot;, 
                               &quot;Median serum c-reactive protein concentration (mg/L)&quot;)

inflammationResults6 &lt;- data.frame(State = yy[ , 1],
                                   Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                                   xx,
                                   row.names = NULL,
                                   stringsAsFactors = FALSE)
</command>
							<property title="Inflammation" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="12" date="1591266428180" uid="374f89e40d6eb797" x="170" y="90">
							<command>## Bootstrap anaemia indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- with(subDF, {
  ifelse(pregnant == 1, &quot;Pregnant&quot;,
    ifelse(pregnant == 2 &amp; lactating == 2, &quot;Non-pregnant non-lactating&quot;,
      ifelse(pregnant == 2 &amp; lactating == 1, &quot;Non-pregnant lactating&quot;, NA)))
})

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;iodine&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

iodineResults6&lt;- data.frame(State = yy[ , 1],
                             Indicator = paste(yy[ , 2], &quot;Median urinary iodine concentration (microgram/L)&quot;, sep = &quot;: &quot;),
                             xx,
                             row.names = NULL,
                             stringsAsFactors = FALSE)
</command>
							<property title="Iodine" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="13" date="1591266428101" uid="7bebc613eccc8477" x="90" y="90">
							<command>## Bootstrap calcium indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;calcium&quot;, &quot;CA1&quot;, &quot;CA2&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), 
                                                 bootMedian, 
                                                 bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;CA1&quot;, &quot;Hypocalcaemia&quot;,
                        ifelse(yy[ , 3] == &quot;CA2&quot;, &quot;Hypercalcaemia&quot;, 
                               &quot;Median serum calcium concentration (mg/dL)&quot;))

calciumResults6  &lt;- data.frame(State = yy[ , 1],
                               Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                               xx,
                               row.names = NULL,
                               stringsAsFactors = FALSE)
</command>
							<property title="Calcium" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="14" date="1591269365208" uid="89fa5197fc7c11e" x="330" y="0">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;vitd&quot;, &quot;VD&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VD&quot;, &quot;Vitamin D deficiency&quot;, 
                               &quot;Median serum 25-hydroxyvitamin D3 concentration (mg/L)&quot;)

vitdResults6 &lt;- data.frame(State = yy[ , 1],
                           Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)
</command>
							<property title="Vitamin D" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="15" date="1591266428170" uid="40eb98bf59e26d52" x="90" y="0">
							<command>## Bootstrap anaemia indicators ################################################
  
## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)
  
## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))
  
## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])
  
## indicator name vector
params &lt;- c(&quot;adjHb&quot;, &quot;AN0&quot;, &quot;AN1&quot;, &quot;AN2&quot;, &quot;AN3&quot;)
  
## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(STATES) * 3, 
                            byrow = TRUE))
  
bootDFnames &lt;- NULL
  
for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}
  
## rename bootDF
names(bootDF) &lt;- bootDFnames
  
## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}
  
## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)
  
## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)
  
## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)
  
## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AN0&quot;, &quot;Any anaemia&quot;, 
                        ifelse(yy[ , 3] == &quot;AN1&quot;, &quot;Mild anaemia&quot;,
                        ifelse(yy[ , 3] == &quot;AN2&quot;, &quot;Moderate anaemia&quot;, 
                               ifelse(yy[ , 3] == &quot;AN3&quot;, &quot;Severe anaemia&quot;, 
                                      &quot;Median adjusted serum haemoglobin concentration (g/dL)&quot;))))

anaemiaResults6 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)
</command>
							<property title="Anaemia" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<edge from="10" to="7"/>
						<edge from="6" to="14"/>
						<edge from="15" to="13"/>
						<edge from="11" to="12"/>
						<edge from="7" to="15"/>
						<edge from="12" to="5"/>
						<edge from="5" to="6"/>
						<edge from="14" to="9"/>
						<edge from="13" to="11"/>
						<edge from="9" to="8"/>
					</graph>
				</subflow>
			</option>
		</node>
		<node id="16" date="1591266941734" uid="741dfc2174b7e501" x="150" y="470">
			<command>## Select states to bootstrap
STATES &lt;- c(3, 9, 15)

## Bootstrap anaemia indicators ################################################
  
## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)
  
## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))
  
## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])
  
## indicator name vector
params &lt;- c(&quot;adjHb&quot;, &quot;AN0&quot;, &quot;AN1&quot;, &quot;AN2&quot;, &quot;AN3&quot;)
  
## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(STATES) * 3, 
                            byrow = TRUE))
  
bootDFnames &lt;- NULL
  
for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}
  
## rename bootDF
names(bootDF) &lt;- bootDFnames
  
## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}
  
## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)
  
## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)
  
## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)
  
## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AN0&quot;, &quot;Any anaemia&quot;, 
                        ifelse(yy[ , 3] == &quot;AN1&quot;, &quot;Mild anaemia&quot;,
                        ifelse(yy[ , 3] == &quot;AN2&quot;, &quot;Moderate anaemia&quot;, 
                               ifelse(yy[ , 3] == &quot;AN3&quot;, &quot;Severe anaemia&quot;, 
                                      &quot;Median adjusted serum haemoglobin concentration (g/dL)&quot;))))

anaemiaResults3 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)

## Bootstrap calcium indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;calcium&quot;, &quot;CA1&quot;, &quot;CA2&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), 
                                                 bootMedian, 
                                                 bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;CA1&quot;, &quot;Hypocalcaemia&quot;,
                        ifelse(yy[ , 3] == &quot;CA2&quot;, &quot;Hypercalcaemia&quot;, 
                               &quot;Median serum calcium concentration (mg/dL)&quot;))

calciumResults3  &lt;- data.frame(State = yy[ , 1],
                               Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                               xx,
                               row.names = NULL,
                               stringsAsFactors = FALSE)

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;crp&quot;, &quot;AI&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AI&quot;, &quot;Acute inflammation&quot;, 
                               &quot;Median serum c-reactive protein concentration (mg/L)&quot;)

inflammationResults3 &lt;- data.frame(State = yy[ , 1],
                                   Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                                   xx,
                                   row.names = NULL,
                                   stringsAsFactors = FALSE)

## Bootstrap anaemia indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- with(subDF, {
  ifelse(pregnant == 1, &quot;Pregnant&quot;,
    ifelse(pregnant == 2 &amp; lactating == 2, &quot;Non-pregnant non-lactating&quot;,
      ifelse(pregnant == 2 &amp; lactating == 1, &quot;Non-pregnant lactating&quot;, NA)))
})

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;iodine&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

iodineResults3 &lt;- data.frame(State = yy[ , 1],
                             Indicator = paste(yy[ , 2], &quot;Median urinary iodine concentration (microgram/L)&quot;, sep = &quot;: &quot;),
                             xx,
                             row.names = NULL,
                             stringsAsFactors = FALSE)

## Bootstrap iron indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;IR1&quot;, &quot;IR2&quot;, &quot;IDA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(locNames$locality[locNames$stateID %in% STATES]) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in unique(locNames$locality[locNames$state == i])) {
    for(k in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
      for(l in params) {
        bootDFnames &lt;- c(bootDFnames, paste(i, j, k, l, sep = &quot;_&quot;))
      }
    }
  }
}

names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$localityID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$localityID == i])
  ## Get current locality name
  currentLocalityName &lt;- unique(locNames$locality[locNames$localityID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, localityID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      cat(&quot;\n&quot;, 
          currentStateName, &quot; - &quot;, 
          currentLocalityName, &quot; - &quot;, 
          j, &quot; - &quot;,
          k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = bootClassic, 
                              params = k,
                              outputColumns = paste(currentStateName,
                                                    currentLocalityName,
                                                    j,
                                                    k,
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, currentLocalityName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename rows
#row.names(xx) &lt;- 1:nrow(xx)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 4] == &quot;IR1&quot;, &quot;Iron deficiency&quot;,
                   ifelse(yy[ , 4] == &quot;IR2&quot;, &quot;Iron overload&quot;, &quot;Iron deficiency anaemia&quot;))

ironResults3 &lt;- data.frame(State = yy[ , 1],
                           Locality = yy[ , 2],
                           Indicator = paste(yy[ , 3], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

ironResults3 &lt;- ironResults3[ironResults3$Indicator != &quot;Child: Iron overload&quot;, ]

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;retinol&quot;, &quot;VA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VA&quot;, &quot;Vitamin A deficiency&quot;, 
                               &quot;Median serum retinol concentration (mg/L)&quot;)

retinolResults3 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;vitd&quot;, &quot;VD&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VD&quot;, &quot;Vitamin D deficiency&quot;, 
                               &quot;Median serum 25-hydroxyvitamin D3 concentration (mg/L)&quot;)

vitdResults3 &lt;- data.frame(State = yy[ , 1],
                           Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

## Combine all
allResults3 &lt;- data.frame(
  rbind(anaemiaResults3, inflammationResults3, ironResults3,
        calciumResults3, iodineResults3, retinolResults3, vitdResults3), stringsAsFactors = FALSE
)

## Save
save(allResults3, file = &quot;resultsSet3.Rdata&quot;)

## Clean-up
rm(allResults3, anaemiaResults3, inflammationResults3, ironResults3, calciumResults3, iodineResults3, retinolResults3, vitdResults3)

</command>
			<property title="Bootstrap Set 3" shape="MODEL"/>
			<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
				<subflow>
					<graph version="0.8" width="920" height="245" locationtype="a" offsetx="100" offsety="50">
						<node id="17" date="1591266291338" uid="b1ef787fec5cf242" x="90" y="80">
							<command>## Bootstrap calcium indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;calcium&quot;, &quot;CA1&quot;, &quot;CA2&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), 
                                                 bootMedian, 
                                                 bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;CA1&quot;, &quot;Hypocalcaemia&quot;,
                        ifelse(yy[ , 3] == &quot;CA2&quot;, &quot;Hypercalcaemia&quot;, 
                               &quot;Median serum calcium concentration (mg/dL)&quot;))

calciumResults3  &lt;- data.frame(State = yy[ , 1],
                               Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                               xx,
                               row.names = NULL,
                               stringsAsFactors = FALSE)
</command>
							<property title="Calcium" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="18" date="1591266291332" uid="c84300bf6eaf99ae" x="170" y="80">
							<command>## Bootstrap anaemia indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- with(subDF, {
  ifelse(pregnant == 1, &quot;Pregnant&quot;,
    ifelse(pregnant == 2 &amp; lactating == 2, &quot;Non-pregnant non-lactating&quot;,
      ifelse(pregnant == 2 &amp; lactating == 1, &quot;Non-pregnant lactating&quot;, NA)))
})

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;iodine&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

iodineResults3 &lt;- data.frame(State = yy[ , 1],
                             Indicator = paste(yy[ , 2], &quot;Median urinary iodine concentration (microgram/L)&quot;, sep = &quot;: &quot;),
                             xx,
                             row.names = NULL,
                             stringsAsFactors = FALSE)
</command>
							<property title="Iodine" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="19" date="1591268918099" uid="23a5f0a8c93f4cf6" x="410" y="0">
							<command>## Combine all
allResults3 &lt;- data.frame(
  rbind(anaemiaResults3, inflammationResults3, ironResults3,
        calciumResults3, iodineResults3, retinolResults3, vitdResults3), stringsAsFactors = FALSE
)

## Save
save(allResults3, file = &quot;resultsSet3.Rdata&quot;)

## Clean-up
rm(allResults3, anaemiaResults3, inflammationResults3, ironResults3, calciumResults3, iodineResults3, retinolResults3, vitdResults3)

</command>
							<property title="Combine results" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="20" date="1591266941734" uid="eb45c0cfa397461b" x="-80" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">in</entry>
							</option>
						</node>
						<node id="21" date="1591266291303" uid="38ab3291f6ee626" x="90" y="0">
							<command>## Bootstrap anaemia indicators ################################################
  
## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)
  
## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))
  
## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])
  
## indicator name vector
params &lt;- c(&quot;adjHb&quot;, &quot;AN0&quot;, &quot;AN1&quot;, &quot;AN2&quot;, &quot;AN3&quot;)
  
## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(STATES) * 3, 
                            byrow = TRUE))
  
bootDFnames &lt;- NULL
  
for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}
  
## rename bootDF
names(bootDF) &lt;- bootDFnames
  
## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}
  
## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)
  
## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)
  
## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)
  
## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AN0&quot;, &quot;Any anaemia&quot;, 
                        ifelse(yy[ , 3] == &quot;AN1&quot;, &quot;Mild anaemia&quot;,
                        ifelse(yy[ , 3] == &quot;AN2&quot;, &quot;Moderate anaemia&quot;, 
                               ifelse(yy[ , 3] == &quot;AN3&quot;, &quot;Severe anaemia&quot;, 
                                      &quot;Median adjusted serum haemoglobin concentration (g/dL)&quot;))))

anaemiaResults3 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)
</command>
							<property title="Anaemia" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="22" date="1591266291321" uid="19aed9bc39c203cd" x="170" y="0">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;crp&quot;, &quot;AI&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AI&quot;, &quot;Acute inflammation&quot;, 
                               &quot;Median serum c-reactive protein concentration (mg/L)&quot;)

inflammationResults3 &lt;- data.frame(State = yy[ , 1],
                                   Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                                   xx,
                                   row.names = NULL,
                                   stringsAsFactors = FALSE)
</command>
							<property title="Inflammation" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="23" date="1591268918103" uid="7cac930de3bcaf14" x="330" y="0">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;vitd&quot;, &quot;VD&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VD&quot;, &quot;Vitamin D deficiency&quot;, 
                               &quot;Median serum 25-hydroxyvitamin D3 concentration (mg/L)&quot;)

vitdResults3 &lt;- data.frame(State = yy[ , 1],
                           Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)
</command>
							<property title="Vitamin D" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="24" date="1591266941734" uid="8fadd84b23f9e7b7" x="490" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">out</entry>
							</option>
						</node>
						<node id="25" date="1591266291310" uid="1fd2c94f719b7172" x="0" y="0">
							<command>## Select states to bootstrap
STATES &lt;- c(3, 9, 15)</command>
							<property title="Setup Set 3" shape="INPUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="26" date="1591266291326" uid="b73ddc723a202c6e" x="250" y="0">
							<command>## Bootstrap iron indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;IR1&quot;, &quot;IR2&quot;, &quot;IDA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(locNames$locality[locNames$stateID %in% STATES]) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in unique(locNames$locality[locNames$state == i])) {
    for(k in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
      for(l in params) {
        bootDFnames &lt;- c(bootDFnames, paste(i, j, k, l, sep = &quot;_&quot;))
      }
    }
  }
}

names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$localityID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$localityID == i])
  ## Get current locality name
  currentLocalityName &lt;- unique(locNames$locality[locNames$localityID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, localityID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      cat(&quot;\n&quot;, 
          currentStateName, &quot; - &quot;, 
          currentLocalityName, &quot; - &quot;, 
          j, &quot; - &quot;,
          k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = bootClassic, 
                              params = k,
                              outputColumns = paste(currentStateName,
                                                    currentLocalityName,
                                                    j,
                                                    k,
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, currentLocalityName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename rows
#row.names(xx) &lt;- 1:nrow(xx)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 4] == &quot;IR1&quot;, &quot;Iron deficiency&quot;,
                   ifelse(yy[ , 4] == &quot;IR2&quot;, &quot;Iron overload&quot;, &quot;Iron deficiency anaemia&quot;))

ironResults3 &lt;- data.frame(State = yy[ , 1],
                           Locality = yy[ , 2],
                           Indicator = paste(yy[ , 3], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

ironResults3 &lt;- ironResults3[ironResults3$Indicator != &quot;Child: Iron overload&quot;, ]
</command>
							<property title="Iron" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="27" date="1591268918111" uid="dd473e66613da160" x="250" y="80">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;retinol&quot;, &quot;VA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VA&quot;, &quot;Vitamin A deficiency&quot;, 
                               &quot;Median serum retinol concentration (mg/L)&quot;)

retinolResults3 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)
</command>
							<property title="Retinol" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<edge from="23" to="19"/>
						<edge from="22" to="18"/>
						<edge from="21" to="17"/>
						<edge from="19" to="24"/>
						<edge from="17" to="22"/>
						<edge from="26" to="27"/>
						<edge from="27" to="23"/>
						<edge from="20" to="25"/>
						<edge from="18" to="26"/>
						<edge from="25" to="21"/>
					</graph>
				</subflow>
			</option>
		</node>
		<node id="28" date="1590566707813" uid="6a1718ed489cd273" x="70" y="60">
			<command>## Clear workspace
rm(list = ls())
gc()

## Load libraries
library(openxlsx)
library(rgdal)
library(rgeos)
library(raster)
library(stringr)


</command>
			<property title="reset"/>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="29" date="1591266875395" uid="7b4167de7c0452bd" x="150" y="330">
			<command>## Select states to bootstrap
STATES &lt;- c(1, 7, 13)

## Bootstrap anaemia indicators ################################################
  
## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)
  
## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))
  
## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])
  
## indicator name vector
params &lt;- c(&quot;adjHb&quot;, &quot;AN0&quot;, &quot;AN1&quot;, &quot;AN2&quot;, &quot;AN3&quot;)
  
## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(STATES) * 3, 
                            byrow = TRUE))
  
bootDFnames &lt;- NULL
  
for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}
  
## rename bootDF
names(bootDF) &lt;- bootDFnames
  
## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}
  
## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)
  
## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)
  
## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)
  
## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AN0&quot;, &quot;Any anaemia&quot;, 
                        ifelse(yy[ , 3] == &quot;AN1&quot;, &quot;Mild anaemia&quot;,
                        ifelse(yy[ , 3] == &quot;AN2&quot;, &quot;Moderate anaemia&quot;, 
                               ifelse(yy[ , 3] == &quot;AN3&quot;, &quot;Severe anaemia&quot;, 
                                      &quot;Median adjusted serum haemoglobin concentration (g/dL)&quot;))))

anaemiaResults1 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)

## Bootstrap calcium indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;calcium&quot;, &quot;CA1&quot;, &quot;CA2&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), 
                                                 bootMedian, 
                                                 bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;CA1&quot;, &quot;Hypocalcaemia&quot;,
                        ifelse(yy[ , 3] == &quot;CA2&quot;, &quot;Hypercalcaemia&quot;, 
                               &quot;Median serum calcium concentration (mg/dL)&quot;))

calciumResults1  &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;crp&quot;, &quot;AI&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AI&quot;, &quot;Acute inflammation&quot;, 
                               &quot;Median serum c-reactive protein concentration (mg/L)&quot;)

inflammationResults1 &lt;- data.frame(State = yy[ , 1],
                                   Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                                   xx,
                                   row.names = NULL,
                                   stringsAsFactors = FALSE)

## Bootstrap anaemia indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- with(subDF, {
  ifelse(pregnant == 1, &quot;Pregnant&quot;,
    ifelse(pregnant == 2 &amp; lactating == 2, &quot;Non-pregnant non-lactating&quot;,
      ifelse(pregnant == 2 &amp; lactating == 1, &quot;Non-pregnant lactating&quot;, NA)))
})

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;iodine&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

iodineResults1 &lt;- data.frame(State = yy[ , 1],
                             Indicator = paste(yy[ , 2], &quot;Median urinary iodine concentration (microgram/L)&quot;, sep = &quot;: &quot;),
                             xx,
                             row.names = NULL,
                             stringsAsFactors = FALSE)

## Bootstrap iron indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;IR1&quot;, &quot;IR2&quot;, &quot;IDA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(locNames$locality[locNames$stateID %in% STATES]) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in unique(locNames$locality[locNames$state == i])) {
    for(k in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
      for(l in params) {
        bootDFnames &lt;- c(bootDFnames, paste(i, j, k, l, sep = &quot;_&quot;))
      }
    }
  }
}

names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$localityID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$localityID == i])
  ## Get current locality name
  currentLocalityName &lt;- unique(locNames$locality[locNames$localityID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, localityID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      cat(&quot;\n&quot;, 
          currentStateName, &quot; - &quot;, 
          currentLocalityName, &quot; - &quot;, 
          j, &quot; - &quot;,
          k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = bootClassic, 
                              params = k,
                              outputColumns = paste(currentStateName,
                                                    currentLocalityName,
                                                    j,
                                                    k,
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, currentLocalityName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename rows
#row.names(xx) &lt;- 1:nrow(xx)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 4] == &quot;IR1&quot;, &quot;Iron deficiency&quot;,
                   ifelse(yy[ , 4] == &quot;IR2&quot;, &quot;Iron overload&quot;, &quot;Iron deficiency anaemia&quot;))

ironResults1 &lt;- data.frame(State = yy[ , 1],
                           Locality = yy[ , 2],
                           Indicator = paste(yy[ , 3], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

ironResults1 &lt;- ironResults1[ironResults1$Indicator != &quot;Child: Iron overload&quot;, ]

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;retinol&quot;, &quot;VA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VA&quot;, &quot;Vitamin A deficiency&quot;, 
                               &quot;Median serum retinol concentration (mg/L)&quot;)

retinolResults1 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;vitd&quot;, &quot;VD&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VD&quot;, &quot;Vitamin D deficiency&quot;, 
                               &quot;Median serum 25-hydroxyvitamin D3 concentration (mg/L)&quot;)

vitdResults1 &lt;- data.frame(State = yy[ , 1],
                           Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

## Combine all
allResults1 &lt;- data.frame(
  rbind(anaemiaResults1, inflammationResults1, ironResults1,
        calciumResults1, iodineResults1, retinolResults1, vitdResults1), stringsAsFactors = FALSE
)

## Save
save(allResults1, file = &quot;resultsSet1.Rdata&quot;)

## Clean-up
rm(allResults1, anaemiaResults1, inflammationResults1, ironResults1, calciumResults1, iodineResults1, retinolResults1, vitdResults1)

</command>
			<property title="Bootstrap Set 1" shape="MODEL"/>
			<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
				<subflow>
					<graph version="0.8" width="920" height="245" locationtype="a" offsetx="100" offsety="50">
						<node id="30" date="1591266875395" uid="7fe5aa3e4452241" x="480" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">out</entry>
							</option>
						</node>
						<node id="31" date="1591265319554" uid="37fd6909559b6599" x="90" y="0">
							<command>## Bootstrap anaemia indicators ################################################
  
## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)
  
## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))
  
## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])
  
## indicator name vector
params &lt;- c(&quot;adjHb&quot;, &quot;AN0&quot;, &quot;AN1&quot;, &quot;AN2&quot;, &quot;AN3&quot;)
  
## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(STATES) * 3, 
                            byrow = TRUE))
  
bootDFnames &lt;- NULL
  
for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}
  
## rename bootDF
names(bootDF) &lt;- bootDFnames
  
## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}
  
## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)
  
## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)
  
## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)
  
## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AN0&quot;, &quot;Any anaemia&quot;, 
                        ifelse(yy[ , 3] == &quot;AN1&quot;, &quot;Mild anaemia&quot;,
                        ifelse(yy[ , 3] == &quot;AN2&quot;, &quot;Moderate anaemia&quot;, 
                               ifelse(yy[ , 3] == &quot;AN3&quot;, &quot;Severe anaemia&quot;, 
                                      &quot;Median adjusted serum haemoglobin concentration (g/dL)&quot;))))

anaemiaResults1 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)
</command>
							<property title="Anaemia" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="32" date="1591265067924" uid="348bd016977075c6" x="0" y="0">
							<command>## Select states to bootstrap
STATES &lt;- c(1, 7, 13)</command>
							<property title="Setup Set 1" shape="INPUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="33" date="1591265736566" uid="585347ea8fca6304" x="410" y="0">
							<command>## Combine all
allResults1 &lt;- data.frame(
  rbind(anaemiaResults1, inflammationResults1, ironResults1,
        calciumResults1, iodineResults1, retinolResults1, vitdResults1), stringsAsFactors = FALSE
)

## Save
save(allResults1, file = &quot;resultsSet1.Rdata&quot;)

## Clean-up
rm(allResults1, anaemiaResults1, inflammationResults1, ironResults1, calciumResults1, iodineResults1, retinolResults1, vitdResults1)

</command>
							<property title="Combine results" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="34" date="1591268364677" uid="ebf9c10f2519df17" x="250" y="60">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;retinol&quot;, &quot;VA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VA&quot;, &quot;Vitamin A deficiency&quot;, 
                               &quot;Median serum retinol concentration (mg/L)&quot;)

retinolResults1 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)
</command>
							<property title="Retinol" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="35" date="1591265450785" uid="a61a9d9882bc61cb" x="170" y="0">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;crp&quot;, &quot;AI&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AI&quot;, &quot;Acute inflammation&quot;, 
                               &quot;Median serum c-reactive protein concentration (mg/L)&quot;)

inflammationResults1 &lt;- data.frame(State = yy[ , 1],
                                   Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                                   xx,
                                   row.names = NULL,
                                   stringsAsFactors = FALSE)
</command>
							<property title="Inflammation" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="36" date="1591266875395" uid="9c6c6719d680b413" x="-80" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">in</entry>
							</option>
						</node>
						<node id="37" date="1591268507658" uid="92276959c2557dcf" x="330" y="0">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;vitd&quot;, &quot;VD&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VD&quot;, &quot;Vitamin D deficiency&quot;, 
                               &quot;Median serum 25-hydroxyvitamin D3 concentration (mg/L)&quot;)

vitdResults1 &lt;- data.frame(State = yy[ , 1],
                           Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)
</command>
							<property title="Vitamin D" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="38" date="1591265397776" uid="b25f05b69d7df552" x="90" y="60">
							<command>## Bootstrap calcium indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;calcium&quot;, &quot;CA1&quot;, &quot;CA2&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), 
                                                 bootMedian, 
                                                 bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;CA1&quot;, &quot;Hypocalcaemia&quot;,
                        ifelse(yy[ , 3] == &quot;CA2&quot;, &quot;Hypercalcaemia&quot;, 
                               &quot;Median serum calcium concentration (mg/dL)&quot;))

calciumResults1  &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)
</command>
							<property title="Calcium" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="39" date="1591265514348" uid="3a3b22c3e58a2ee8" x="170" y="60">
							<command>## Bootstrap anaemia indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- with(subDF, {
  ifelse(pregnant == 1, &quot;Pregnant&quot;,
    ifelse(pregnant == 2 &amp; lactating == 2, &quot;Non-pregnant non-lactating&quot;,
      ifelse(pregnant == 2 &amp; lactating == 1, &quot;Non-pregnant lactating&quot;, NA)))
})

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;iodine&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

iodineResults1 &lt;- data.frame(State = yy[ , 1],
                             Indicator = paste(yy[ , 2], &quot;Median urinary iodine concentration (microgram/L)&quot;, sep = &quot;: &quot;),
                             xx,
                             row.names = NULL,
                             stringsAsFactors = FALSE)
</command>
							<property title="Iodine" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="40" date="1591265574545" uid="899a3995a35a8efd" x="250" y="0">
							<command>## Bootstrap iron indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;IR1&quot;, &quot;IR2&quot;, &quot;IDA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(locNames$locality[locNames$stateID %in% STATES]) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in unique(locNames$locality[locNames$state == i])) {
    for(k in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
      for(l in params) {
        bootDFnames &lt;- c(bootDFnames, paste(i, j, k, l, sep = &quot;_&quot;))
      }
    }
  }
}

names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$localityID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$localityID == i])
  ## Get current locality name
  currentLocalityName &lt;- unique(locNames$locality[locNames$localityID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, localityID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      cat(&quot;\n&quot;, 
          currentStateName, &quot; - &quot;, 
          currentLocalityName, &quot; - &quot;, 
          j, &quot; - &quot;,
          k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = bootClassic, 
                              params = k,
                              outputColumns = paste(currentStateName,
                                                    currentLocalityName,
                                                    j,
                                                    k,
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, currentLocalityName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename rows
#row.names(xx) &lt;- 1:nrow(xx)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 4] == &quot;IR1&quot;, &quot;Iron deficiency&quot;,
                   ifelse(yy[ , 4] == &quot;IR2&quot;, &quot;Iron overload&quot;, &quot;Iron deficiency anaemia&quot;))

ironResults1 &lt;- data.frame(State = yy[ , 1],
                           Locality = yy[ , 2],
                           Indicator = paste(yy[ , 3], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

ironResults1 &lt;- ironResults1[ironResults1$Indicator != &quot;Child: Iron overload&quot;, ]
</command>
							<property title="Iron" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<edge from="34" to="37"/>
						<edge from="37" to="33"/>
						<edge from="38" to="35"/>
						<edge from="35" to="39"/>
						<edge from="39" to="40"/>
						<edge from="31" to="38"/>
						<edge from="33" to="30"/>
						<edge from="36" to="32"/>
						<edge from="32" to="31"/>
						<edge from="40" to="34"/>
					</graph>
				</subflow>
			</option>
		</node>
		<node id="41" date="1591264992898" uid="690f4e0534c61a04" x="60" y="330">
			<command>load(&quot;indicators.Rdata&quot;)

REPLICATES &lt;- 399</command>
			<property title="Load indicators data" shape="INOUT"/>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="42" date="1591266995446" uid="f811f8c1c396cf11" x="250" y="400">
			<command>## Select states to bootstrap
STATES &lt;- c(5, 11, 17)

## Bootstrap anaemia indicators ################################################
  
## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)
  
## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))
  
## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])
  
## indicator name vector
params &lt;- c(&quot;adjHb&quot;, &quot;AN0&quot;, &quot;AN1&quot;, &quot;AN2&quot;, &quot;AN3&quot;)
  
## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(STATES) * 3, 
                            byrow = TRUE))
  
bootDFnames &lt;- NULL
  
for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}
  
## rename bootDF
names(bootDF) &lt;- bootDFnames
  
## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}
  
## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)
  
## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)
  
## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)
  
## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AN0&quot;, &quot;Any anaemia&quot;, 
                        ifelse(yy[ , 3] == &quot;AN1&quot;, &quot;Mild anaemia&quot;,
                        ifelse(yy[ , 3] == &quot;AN2&quot;, &quot;Moderate anaemia&quot;, 
                               ifelse(yy[ , 3] == &quot;AN3&quot;, &quot;Severe anaemia&quot;, 
                                      &quot;Median adjusted serum haemoglobin concentration (g/dL)&quot;))))

anaemiaResults5 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)

## Bootstrap calcium indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;calcium&quot;, &quot;CA1&quot;, &quot;CA2&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), 
                                                 bootMedian, 
                                                 bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;CA1&quot;, &quot;Hypocalcaemia&quot;,
                        ifelse(yy[ , 3] == &quot;CA2&quot;, &quot;Hypercalcaemia&quot;, 
                               &quot;Median serum calcium concentration (mg/dL)&quot;))

calciumResults5  &lt;- data.frame(State = yy[ , 1],
                               Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                               xx,
                               row.names = NULL,
                               stringsAsFactors = FALSE)

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;crp&quot;, &quot;AI&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AI&quot;, &quot;Acute inflammation&quot;, 
                               &quot;Median serum c-reactive protein concentration (mg/L)&quot;)

inflammationResults5 &lt;- data.frame(State = yy[ , 1],
                                   Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                                   xx,
                                   row.names = NULL,
                                   stringsAsFactors = FALSE)

## Bootstrap anaemia indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- with(subDF, {
  ifelse(pregnant == 1, &quot;Pregnant&quot;,
    ifelse(pregnant == 2 &amp; lactating == 2, &quot;Non-pregnant non-lactating&quot;,
      ifelse(pregnant == 2 &amp; lactating == 1, &quot;Non-pregnant lactating&quot;, NA)))
})

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;iodine&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

iodineResults5 &lt;- data.frame(State = yy[ , 1],
                             Indicator = paste(yy[ , 2], &quot;Median urinary iodine concentration (microgram/L)&quot;, sep = &quot;: &quot;),
                             xx,
                             row.names = NULL,
                             stringsAsFactors = FALSE)

## Bootstrap iron indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;IR1&quot;, &quot;IR2&quot;, &quot;IDA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(locNames$locality[locNames$stateID %in% STATES]) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in unique(locNames$locality[locNames$state == i])) {
    for(k in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
      for(l in params) {
        bootDFnames &lt;- c(bootDFnames, paste(i, j, k, l, sep = &quot;_&quot;))
      }
    }
  }
}

names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$localityID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$localityID == i])
  ## Get current locality name
  currentLocalityName &lt;- unique(locNames$locality[locNames$localityID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, localityID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      cat(&quot;\n&quot;, 
          currentStateName, &quot; - &quot;, 
          currentLocalityName, &quot; - &quot;, 
          j, &quot; - &quot;,
          k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = bootClassic, 
                              params = k,
                              outputColumns = paste(currentStateName,
                                                    currentLocalityName,
                                                    j,
                                                    k,
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, currentLocalityName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename rows
#row.names(xx) &lt;- 1:nrow(xx)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 4] == &quot;IR1&quot;, &quot;Iron deficiency&quot;,
                   ifelse(yy[ , 4] == &quot;IR2&quot;, &quot;Iron overload&quot;, &quot;Iron deficiency anaemia&quot;))

ironResults5 &lt;- data.frame(State = yy[ , 1],
                           Locality = yy[ , 2],
                           Indicator = paste(yy[ , 3], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

ironResults5 &lt;- ironResults5[ironResults5$Indicator != &quot;Child: Iron overload&quot;, ]

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;retinol&quot;, &quot;VA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VA&quot;, &quot;Vitamin A deficiency&quot;, 
                               &quot;Median serum retinol concentration (mg/L)&quot;)

retinolResults5 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;vitd&quot;, &quot;VD&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VD&quot;, &quot;Vitamin D deficiency&quot;, 
                               &quot;Median serum 25-hydroxyvitamin D3 concentration (mg/L)&quot;)

vitdResults5 &lt;- data.frame(State = yy[ , 1],
                           Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

## Combine all
allResults5 &lt;- data.frame(
  rbind(anaemiaResults5, inflammationResults5, ironResults5,
        calciumResults5, iodineResults5, retinolResults5, vitdResults5), stringsAsFactors = FALSE
)

## Save
save(allResults5, file = &quot;resultsSet5.Rdata&quot;)

## Clean-up
rm(allResults5, anaemiaResults5, inflammationResults5, ironResults5, calciumResults5, iodineResults5, retinolResults5, vitdResults5)

</command>
			<property title="Bootstrap Set 5" shape="MODEL"/>
			<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
				<subflow>
					<graph version="0.8" width="920" height="245" locationtype="a" offsetx="100" offsety="50">
						<node id="43" date="1591269245236" uid="d539243f5c55e2fd" x="250" y="80">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;retinol&quot;, &quot;VA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VA&quot;, &quot;Vitamin A deficiency&quot;, 
                               &quot;Median serum retinol concentration (mg/L)&quot;)

retinolResults5 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)
</command>
							<property title="Retinol" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="44" date="1591266995446" uid="a253bba1c3e1da52" x="-80" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">in</entry>
							</option>
						</node>
						<node id="45" date="1591266995446" uid="2620d8a97e4a6fab" x="490" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">out</entry>
							</option>
						</node>
						<node id="46" date="1591266428224" uid="e39d56b2577e6ea1" x="170" y="0">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;crp&quot;, &quot;AI&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AI&quot;, &quot;Acute inflammation&quot;, 
                               &quot;Median serum c-reactive protein concentration (mg/L)&quot;)

inflammationResults5 &lt;- data.frame(State = yy[ , 1],
                                   Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                                   xx,
                                   row.names = NULL,
                                   stringsAsFactors = FALSE)
</command>
							<property title="Inflammation" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="47" date="1591266428151" uid="bacf35bef41f003e" x="90" y="80">
							<command>## Bootstrap calcium indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;calcium&quot;, &quot;CA1&quot;, &quot;CA2&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), 
                                                 bootMedian, 
                                                 bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;CA1&quot;, &quot;Hypocalcaemia&quot;,
                        ifelse(yy[ , 3] == &quot;CA2&quot;, &quot;Hypercalcaemia&quot;, 
                               &quot;Median serum calcium concentration (mg/dL)&quot;))

calciumResults5  &lt;- data.frame(State = yy[ , 1],
                               Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                               xx,
                               row.names = NULL,
                               stringsAsFactors = FALSE)
</command>
							<property title="Calcium" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="48" date="1591269245242" uid="7d2e45288e6c9f5e" x="410" y="0">
							<command>## Combine all
allResults5 &lt;- data.frame(
  rbind(anaemiaResults5, inflammationResults5, ironResults5,
        calciumResults5, iodineResults5, retinolResults5, vitdResults5), stringsAsFactors = FALSE
)

## Save
save(allResults5, file = &quot;resultsSet5.Rdata&quot;)

## Clean-up
rm(allResults5, anaemiaResults5, inflammationResults5, ironResults5, calciumResults5, iodineResults5, retinolResults5, vitdResults5)

</command>
							<property title="Combine results" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="49" date="1591266428160" uid="42655fa61838dbe4" x="170" y="80">
							<command>## Bootstrap anaemia indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- with(subDF, {
  ifelse(pregnant == 1, &quot;Pregnant&quot;,
    ifelse(pregnant == 2 &amp; lactating == 2, &quot;Non-pregnant non-lactating&quot;,
      ifelse(pregnant == 2 &amp; lactating == 1, &quot;Non-pregnant lactating&quot;, NA)))
})

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;iodine&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

iodineResults5 &lt;- data.frame(State = yy[ , 1],
                             Indicator = paste(yy[ , 2], &quot;Median urinary iodine concentration (microgram/L)&quot;, sep = &quot;: &quot;),
                             xx,
                             row.names = NULL,
                             stringsAsFactors = FALSE)
</command>
							<property title="Iodine" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="50" date="1591269245245" uid="75607cdd26d8d73c" x="330" y="0">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;vitd&quot;, &quot;VD&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VD&quot;, &quot;Vitamin D deficiency&quot;, 
                               &quot;Median serum 25-hydroxyvitamin D3 concentration (mg/L)&quot;)

vitdResults5 &lt;- data.frame(State = yy[ , 1],
                           Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)
</command>
							<property title="Vitamin D" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="51" date="1591266428125" uid="e1dee5fb4342c5c4" x="0" y="0">
							<command>## Select states to bootstrap
STATES &lt;- c(5, 11, 17)</command>
							<property title="Setup Set 5" shape="INPUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="52" date="1591266428133" uid="fe9cfd7b95abeac1" x="250" y="0">
							<command>## Bootstrap iron indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;IR1&quot;, &quot;IR2&quot;, &quot;IDA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(locNames$locality[locNames$stateID %in% STATES]) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in unique(locNames$locality[locNames$state == i])) {
    for(k in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
      for(l in params) {
        bootDFnames &lt;- c(bootDFnames, paste(i, j, k, l, sep = &quot;_&quot;))
      }
    }
  }
}

names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$localityID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$localityID == i])
  ## Get current locality name
  currentLocalityName &lt;- unique(locNames$locality[locNames$localityID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, localityID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      cat(&quot;\n&quot;, 
          currentStateName, &quot; - &quot;, 
          currentLocalityName, &quot; - &quot;, 
          j, &quot; - &quot;,
          k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = bootClassic, 
                              params = k,
                              outputColumns = paste(currentStateName,
                                                    currentLocalityName,
                                                    j,
                                                    k,
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, currentLocalityName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename rows
#row.names(xx) &lt;- 1:nrow(xx)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 4] == &quot;IR1&quot;, &quot;Iron deficiency&quot;,
                   ifelse(yy[ , 4] == &quot;IR2&quot;, &quot;Iron overload&quot;, &quot;Iron deficiency anaemia&quot;))

ironResults5 &lt;- data.frame(State = yy[ , 1],
                           Locality = yy[ , 2],
                           Indicator = paste(yy[ , 3], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

ironResults5 &lt;- ironResults5[ironResults5$Indicator != &quot;Child: Iron overload&quot;, ]
</command>
							<property title="Iron" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="53" date="1591266428212" uid="6335c672bb62db5f" x="90" y="0">
							<command>## Bootstrap anaemia indicators ################################################
  
## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)
  
## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))
  
## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])
  
## indicator name vector
params &lt;- c(&quot;adjHb&quot;, &quot;AN0&quot;, &quot;AN1&quot;, &quot;AN2&quot;, &quot;AN3&quot;)
  
## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(STATES) * 3, 
                            byrow = TRUE))
  
bootDFnames &lt;- NULL
  
for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}
  
## rename bootDF
names(bootDF) &lt;- bootDFnames
  
## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}
  
## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)
  
## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)
  
## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)
  
## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AN0&quot;, &quot;Any anaemia&quot;, 
                        ifelse(yy[ , 3] == &quot;AN1&quot;, &quot;Mild anaemia&quot;,
                        ifelse(yy[ , 3] == &quot;AN2&quot;, &quot;Moderate anaemia&quot;, 
                               ifelse(yy[ , 3] == &quot;AN3&quot;, &quot;Severe anaemia&quot;, 
                                      &quot;Median adjusted serum haemoglobin concentration (g/dL)&quot;))))

anaemiaResults5 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)
</command>
							<property title="Anaemia" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<edge from="47" to="46"/>
						<edge from="48" to="45"/>
						<edge from="46" to="49"/>
						<edge from="43" to="50"/>
						<edge from="44" to="51"/>
						<edge from="51" to="53"/>
						<edge from="52" to="43"/>
						<edge from="53" to="47"/>
						<edge from="50" to="48"/>
						<edge from="49" to="52"/>
					</graph>
				</subflow>
			</option>
		</node>
		<node id="54" date="1590739159560" uid="5d642172d6c86830" x="240" y="240">
			<command>save(list = ls(), file = &quot;indicators.Rdata&quot;)</command>
			<property title="Save indicators" shape="INOUT"/>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="55" date="1590568350990" uid="13f85130e81f3ef9" x="150" y="150">
			<command>## Create &apos;ageGrp&apos;
mnData$ageGrp &lt;- NA
## Children
mnData$ageGrp[mnData$childAge &lt;= 60 &amp; is.na(mnData$womanAge)] &lt;- 1
mnData$ageGrp[is.na(mnData$childAge) &amp; is.na(mnData$womanAge) &amp; mnData$group == &quot;Child&quot;] &lt;- 1
## Adults (women)
mnData$ageGrp[mnData$womanAge %in% 15:49 &amp; is.na(mnData$childAge)] &lt;- 2
mnData$ageGrp[is.na(mnData$childAge) &amp; is.na(mnData$womanAge) &amp; mnData$group != &quot;Child&quot;] &lt;- 2 ## fix [was: 1]

## Check for NAs in ageGrp
table(mnData$ageGrp, useNA = &quot;always&quot;)
## Investigate NAs
temp &lt;- subset(mnData, is.na(ageGrp), select = c(childAge, womanAge, group, ageGrp))
View(temp) ## Problems with missing / out of range ages ... *** We will probably need to censor these ***
rm(temp)


## Special classifications: Pregnant
##   1 = YES
##   2 = NO
##   9 = Don&apos;t know ## Added by MM
##   NA = not known status or status does not apply
mnData$pregnant &lt;- NA
mnData$pregnant[mnData$group == &quot;Pregnant Principal carer&quot;]                                          &lt;- 1
mnData$pregnant[mnData$group == &quot;Pregnant Not Principal Carer&quot;]                                      &lt;- 1 ## fixed &quot;carer&quot;
mnData$pregnant[mnData$group == &quot;Pregnant and lactating Principal Carer&quot;]                            &lt;- 1 ## Fixed &quot;Lactating&quot;
mnData$pregnant[mnData$group == &quot;Principal carer nighther pregnant nor lactating&quot;]                   &lt;- 2
mnData$pregnant[mnData$group == &quot;Lactating Principal carer&quot;]                                         &lt;- 2
mnData$pregnant[mnData$group == &quot;Woman in child bearing age (pregnancy/lactation status not known)&quot;] &lt;- 9 ## added by MM

table(mnData$group, mnData$pregnant)

## Special classifications: lactating
##   1 = YES
##   2 = NO
##   9 = Don&apos;t know ## Added by MM
##   NA = not known status or status does not apply
mnData$lactating &lt;- NA
mnData$lactating[mnData$group == &quot;Pregnant Principal carer&quot;]                                          &lt;- 2
mnData$lactating[mnData$group == &quot;Pregnant Not Principal Carer&quot;]                                      &lt;- 2 ## fixed &quot;carer&quot;
mnData$lactating[mnData$group == &quot;Pregnant and lactating Principal Carer&quot;]                            &lt;- 1 ## Fixed &quot;Lactating&quot;
mnData$lactating[mnData$group == &quot;Principal carer nighther pregnant nor lactating&quot;]                   &lt;- 2
mnData$lactating[mnData$group == &quot;Lactating Principal carer&quot;]                                         &lt;- 1
mnData$lactating[mnData$group == &quot;Woman in child bearing age (pregnancy/lactation status not known)&quot;] &lt;- 9 ## added by MM

table(mnData$group, mnData$lactating)

## Special classifications: Pregnant OR Lactating Woman (PLW) ## Added by MM ... may be useful
##   1 = YES
##   2 = NO
##   9 = Don&apos;t know ## Added by MM
##   NA = not known status or status does not apply
mnData$plw &lt;- NA
mnData$plw[mnData$group == &quot;Pregnant Principal carer&quot;]                                          &lt;- 1
mnData$plw[mnData$group == &quot;Pregnant Not Principal Carer&quot;]                                      &lt;- 1 ## Fixed &quot;carer&quot;
mnData$plw[mnData$group == &quot;Pregnant and lactating Principal Carer&quot;]                            &lt;- 1 ## Fixed &quot;Lactating&quot;
mnData$plw[mnData$group == &quot;Principal carer nighther pregnant nor lactating&quot;]                   &lt;- 2
mnData$plw[mnData$group == &quot;Lactating Principal carer&quot;]                                         &lt;- 1
mnData$plw[mnData$group == &quot;Woman in child bearing age (pregnancy/lactation status not known)&quot;] &lt;- 9 ## added by MM

table(mnData$group, mnData$plw)

</command>
			<property title="cleanData"/>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="56" date="1590567987053" uid="601967411aca41c1" x="60" y="150">
			<command>## Read micronutrient data
mnData &lt;- read.xlsx(&quot;data/mnData_master_Sudan_V12.xlsx&quot;, sheet = 1)

## Read PSU data
psuData &lt;- read.csv(&quot;data/updatedPSU.csv&quot;, stringsAsFactors = FALSE)

## Read locality and state administrative structure data
locNames &lt;- read.csv(&quot;data/locNames.csv&quot;, stringsAsFactors = FALSE)

## Remove arabic names for states and localities
locNames &lt;- subset(locNames, select = c(-stateAR, -localityAR))

## Read sudan boundary maps
sudan01 &lt;- readOGR(dsn = &quot;data/sudan.gpkg&quot;, layer = &quot;state&quot;, verbose = FALSE)

## Read SRTM raster for elevation data
sudanSRTM &lt;- raster(x = &quot;data/srtm/SDN_alt.vrt&quot;)

## Read Sudan locality shapefile
#sudan02 &lt;- readOGR(dsn = &quot;data/locality/&quot;, layer = &quot;sudan02&quot;)

## Check that all numeric variables are numeric and change accordingly and
## rename variables to more coherent labels
mnData &lt;- data.frame(stateID = as.integer(mnData$state),
	barcode = as.integer(mnData$bc),
	localityID = as.integer(mnData$locality),
	psu = as.integer(mnData$psu),
	womanAge = as.numeric(mnData$m.age),
	childAge = as.numeric(mnData$ch.age),
	sex = as.integer(mnData$sex),
	muac = as.numeric(mnData$muac),
	weight = as.numeric(mnData$ch.weight),
	height = as.numeric(mnData$ch.height),
	oedema = as.numeric(mnData$ch.oedema),
	hb = as.numeric(mnData$hb),
	group = mnData$group,
	calcium = as.numeric(mnData$calcium),
	crp = as.numeric(mnData$crp),
	ferritin = as.numeric(mnData$ferritin),
	iodine = as.numeric(mnData$iodine),
	retinol = as.numeric(mnData$retinol),
	vitd = as.numeric(mnData$vitD))</command>
			<property title="getData" shape="INPUT"/>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="57" date="1591264750441" uid="c6a02839757e7d92" x="150" y="240">
			<command>## Add elevation data to mnData
mnData &lt;- merge(psuData[ , c(&quot;psu&quot;, &quot;longitude&quot;, &quot;latitude&quot;)], mnData, by = &quot;psu&quot;, all.y = TRUE)

sudanAlt_subset &lt;- intersect(sudanSRTM, sudan01)
sudanAlt_subset &lt;- mask(sudanAlt_subset, sudan01)

mnData_spdf &lt;- SpatialPointsDataFrame(coords = mnData[ , c(&quot;longitude&quot;, &quot;latitude&quot;)], 
	data = mnData,
	proj4string = CRS(proj4string(sudan01)))

## Get corresponding altitude from SRTM data
altitude &lt;- extract(sudanAlt_subset, mnData_spdf)

## Add altitude to mnData
mnData &lt;- data.frame(mnData, altitude, stringsAsFactors = FALSE)

## Adjust hb based on altitude
adjHb &lt;- with(mnData, {
	ifelse(altitude &gt;= 1000 &amp; altitude &lt; 1500, hb - 2,
	  ifelse(altitude &gt;= 1500 &amp; altitude &lt; 2000, hb - 5,
	    ifelse(altitude &gt;= 2000 &amp; altitude &lt; 2500, hb - 8,
	      ifelse(altitude &gt;= 2500 &amp; altitude &lt; 3000, hb - 13,
	        ifelse(altitude &gt;= 3000 &amp; altitude &lt; 3500, hb - 19,
	          ifelse(altitude &gt;= 3500 &amp; altitude &lt; 4000, hb - 27,
	            ifelse(altitude &gt;= 4000 &amp; altitude &lt; 4500, hb - 35,
	             ifelse(altitude &gt;= 4500, hb - 45, hb))))))))
})

## Adjust ferritin based on crp value
adjFerritin &lt;- with(mnData, {
	ifelse(crp &gt; 5, ferritin * 0.65, ferritin)
})

## Add to mnData
mnData &lt;- data.frame(mnData, adjHb, adjFerritin, stringsAsFactors = FALSE)

## Create indicators concatenating data.frame
indicators &lt;- mnData[ , c(&quot;stateID&quot;, &quot;localityID&quot;, &quot;psu&quot;, &quot;longitude&quot;, &quot;latitude&quot;, 
                          &quot;ageGrp&quot;, &quot;pregnant&quot;, &quot;lactating&quot;, &quot;plw&quot;,
                          &quot;hb&quot;, &quot;adjHb&quot;, &quot;ferritin&quot;, &quot;adjFerritin&quot;, 
                          &quot;crp&quot;, &quot;calcium&quot;, &quot;iodine&quot;, &quot;retinol&quot;, &quot;vitd&quot;)]

## Clean-up
rm(sudanAlt_subset, mnData_spdf, altitude, adjHb, adjFerritin)

## Recode anaemia indicators ###################################
##   1 = Severe anaemia
##   2 = Moderate anaemaia
##   3 = Mild anaemia
##   4 = No anaemia

## AN: Anaemia status
AN &lt;- NA

## under 5 children
AN[mnData$ageGrp == 1] &lt;- recode_hb_u5(x = mnData[mnData$ageGr == 1, ], factor = 10)
                                          
## non-pregnant WRA
AN[mnData$ageGrp == 2 &amp; mnData$pregnant == 2] &lt;- recode_hb_wra(x = mnData[mnData$ageGrp == 2 &amp; mnData$pregnant == 2, ], factor = 10)
   
## pregnant WRA
AN[mnData$ageGrp == 2 &amp; mnData$pregnant == 1] &lt;- recode_hb_pregnant(x = mnData[mnData$ageGrp == 2 &amp; mnData$pregnant == 1, ], factor = 10)

## AN1: Mild anaemia
AN1 &lt;- recode(var = AN, recodes = &quot;1:2=0;3=1;4=0&quot;)                                                                                     
## AN2: Moderate anaemia
AN2 &lt;- recode(var = AN, recodes = &quot;1=0;2=1;3:4=0&quot;)

## AN3: Severe anaemia
AN3 &lt;- recode(var = AN, recodes = &quot;1=1;2:4=0&quot;)

## AN0: Any anaemia
AN0 &lt;- ifelse(AN1 == 1 | AN2 == 1 | AN3 == 1, 1, 0)

## Concatenate recoded indicators into indicators data.frame
indicators &lt;- data.frame(indicators, AN, AN1, AN2, AN3, AN0, stringsAsFactors = FALSE)

rm(AN, AN1, AN2, AN3, AN0)
                                                                                                                           







## AI: Acute inflammation indicators
##   1 = Inflammation
##   0 = No inflammation

AI &lt;- findInterval(mnData$crp, vec = c(0, 5, Inf), rightmost.closed = TRUE, left.open = TRUE)
AI &lt;- AI - 1

## Add AI to indicators
indicators &lt;- data.frame(indicators, AI, stringsAsFactors = FALSE)

## Clean-up
rm(AI)

## Recode iron stores indicators
##   1 = Iron deficiency
##   2 = Normal iron levels
##   3 = Iron overload

IR &lt;- with(mnData, {
	ifelse(ageGrp == 1 &amp; crp &gt; 5 &amp; (ferritin * 0.65) &lt; 12, 1,
	  ifelse(ageGrp == 1 &amp; crp &lt;= 5 &amp; ferritin &lt; 12, 1,
	    ifelse(ageGrp == 2 &amp; crp &gt; 5 &amp; (ferritin * 0.65) &lt; 15, 1,
	      ifelse(ageGrp == 2 &amp; crp &lt;= 5 &amp; ferritin &lt; 15, 1,
	        ifelse(ageGrp == 2 &amp; crp &gt; 5 &amp; (ferritin * 0.65) &gt; 150, 3,
	          ifelse(ageGrp == 2 &amp; crp &lt; 5 &amp; ferritin &gt; 150, 3, 2))))))
})


## IR1: Iron deficiency
IR1 &lt;- recode(var = IR, recodes = &quot;1=1;2=0&quot;)

## IR2: Iron overload
IR2 &lt;- ifelse(mnData$ageGrp == 2 &amp; IR == 3, 1,
         ifelse(mnData$ageGrp == 2 &amp; IR != 3, 0, NA))
         
## IDA: iron-deficiency anaemia
IDA &lt;- ifelse(IR == 1 &amp; indicators$AN != 4, 1, 0)


## Add IR indicators to indicators data.frame
indicators &lt;- data.frame(indicators, IR, IR1, IR2, IDA, stringsAsFactors = FALSE)

## clean-up
rm(IR, IR1, IR2, IDA)

## Recode calcium
##   1 = Hypocalcemia
##   2 = Hypercalcemia
##   3 = Normocalcemia

CA &lt;- with(mnData, {
	ifelse(ageGrp == 1 &amp; childAge %in% 12:60 &amp; calcium &lt; 9.4, 1,
	  ifelse(ageGrp == 2 &amp; calcium &lt; 8.8, 1,
	    ifelse(ageGrp == 1 &amp; childAge %in% 12:60 &amp; calcium &gt; 10.8, 2,
	      ifelse(ageGrp == 2 &amp; calcium &gt; 10, 2,
	        ifelse(ageGrp == 1 &amp; childAge %in% 12:60 &amp; calcium &gt;= 9.4 &amp; calcium &lt;= 10.8, 3,
	          ifelse(ageGrp == 2 &amp; calcium &gt;= 8.8 &amp; calcium &gt;= 10, 3, NA))))))
})

## Check - Randomly checked 10 lines of data - all checks out
cbind(mnData[ , c(&quot;ageGrp&quot;, &quot;childAge&quot;, &quot;calcium&quot;)], CA)

## Recode to hypocalcemia
CA1 &lt;- ifelse(CA == 1, 1, 0)

## Recode to hypercalcemia
CA2 &lt;- ifelse(CA == 2, 1, 0)

## Add to indicators data.frame
indicators &lt;- data.frame(indicators, CA, CA1, CA2, stringsAsFactors = FALSE)

## Clean-up
rm(CA, CA1, CA2)


## Recode iodine indicators
##   1 = Severe iodine deficiency - non-pregnant non-lactating WRA
##   2 = Moderate iodine deficiency - non-pregnant non-lactating WRA
##   3 = Mild iodine deficiency - non-pregnant non-lactating WRA
##   4 = Iodine insufficiency - pregnant (lactating or not) WRA
##   5 = Iodine insufficiency - lactating non-pregnant WRA
##   6 = Above requirements - any group
##   7 = Excessive - any group
##   8 = Adequate - any group

ID &lt;- with(mnData, {
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 2 &amp; iodine &lt; 20, 1,
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 2 &amp; iodine &gt;= 20 &amp; iodine &lt; 50, 2,
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 2 &amp; iodine &gt;= 50 &amp; iodine &lt; 100, 3,
  ifelse(ageGrp == 2 &amp; pregnant == 1 &amp; iodine &lt; 150, 4,
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 1 &amp; iodine &lt; 100, 5,
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 2 &amp; iodine &gt;= 200 &amp; iodine &lt; 300, 6,
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 2 &amp; iodine &gt;= 300, 7,
  ifelse(ageGrp == 2 &amp; pregnant == 1 &amp; iodine &gt;= 250 &amp; iodine &lt; 500, 6,
  ifelse(ageGrp == 2 &amp; pregnant == 1 &amp; iodine &gt;= 500, 7,
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 2 &amp; iodine &gt;= 100 &amp; iodine &lt; 200, 8,
  ifelse(ageGrp == 2 &amp; pregnant == 1 &amp; iodine &gt;= 150 &amp; iodine &lt; 250, 8,
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 1 &amp; iodine &gt;= 100, 8, NA))))))))))))
})

## Recode ID into specific indicators

## ID1A: Insufficient iodine in non-pregnant lactating WRA
ID1A &lt;- ifelse(mnData$lactating == 1 &amp; mnData$pregnant == 2 &amp; ID == 5, 1,
          ifelse(mnData$lactating == 1 &amp; mnData$pregnant == 2 &amp; ID != 5, 0, NA))

## Check recode - all values check out
cbind(mnData[ , c(&quot;pregnant&quot;, &quot;lactating&quot;)], ID, ID1A)

## ID1B: Insufficient iodine in pregnant WRA
ID1B &lt;- ifelse(mnData$pregnant == 1 &amp; ID == 4, 1,
	     ifelse(mnData$pregnant == 2 &amp; ID != 4, 0, NA))

## Check recode - all values check out
cbind(mnData[ , c(&quot;pregnant&quot;, &quot;lactating&quot;)], ID, ID1B)

## ID2: Mild iodine deficiency in non-pregnant non-lactating WRA
ID2 &lt;- ifelse(mnData$pregnant == 2 &amp; mnData$lactating == 2 &amp; ID == 3, 1,
         ifelse(mnData$pregnant == 2 &amp; mnData$lactating == 2 &amp; ID != 3, 0, NA))

## Check recode
cbind(mnData[ , c(&quot;pregnant&quot;, &quot;lactating&quot;)], ID, ID2)

## ID3: Moderate iodine deficiency in non-pregnant non-lactating WRA
ID3 &lt;- ifelse(mnData$pregnant == 2 &amp; mnData$lactating == 2 &amp; ID == 2, 1,
	    ifelse(mnData$pregnant == 2 &amp; mnData$lactating == 2 &amp; ID != 2, 0, NA))

## Check recode
cbind(mnData[ , c(&quot;pregnant&quot;, &quot;lactating&quot;)], ID, ID3)

## ID4: Severe iodine deficiency in non-pregnant non-lactating WRA
ID4 &lt;- ifelse(mnData$pregnant == 2 &amp; mnData$lactating == 2 &amp; ID == 1, 1,
	ifelse(mnData$pregnant == 2 &amp; mnData$lactating == 2 &amp; ID != 1, 0, NA))

## Check recode
cbind(mnData[ , c(&quot;pregnant&quot;, &quot;lactating&quot;)], ID, ID4)

## ID5: Above requirements
ID5 &lt;- ifelse(ID == 6, 1, 0)

## check recode
cbind(mnData[ , c(&quot;pregnant&quot;, &quot;lactating&quot;)], ID, ID5)

## ID6: Excessive
ID6 &lt;- ifelse(ID == 7, 1, 0)

## check recode
cbind(mnData[ , c(&quot;pregnant&quot;, &quot;lactating&quot;)], ID, ID6)

## Add to indicators
indicators &lt;- data.frame(indicators, ID, ID1A, ID1B, ID2, ID3, ID4, ID5, ID6, stringsAsFactors = FALSE)

## Clean-up
rm(ID, ID1A, ID1B, ID2, ID3, ID4, ID5, ID6)




## VA: Retinol (Vitamin A indicators) - assumes retinol is in micromol/L units
##   1 = deficient
##   0 = Not deficient

VA &lt;- findInterval(mnData$retinol, vec = c(0, 0.7, Inf), rightmost.closed = TRUE, left.open = TRUE)
VA &lt;- VA - 1

## Add VA to indicators
indicators &lt;- data.frame(indicators, VA, stringsAsFactors = FALSE)

## Clean-up
rm(VA)

## VD: Vitamin D - assumes vitamin D is in nanomol/L units
##   1 = deficient
##   0 = Not deficient

VD &lt;- findInterval(mnData$vitd, vec = c(0, 25, Inf), rightmost.closed = TRUE, left.open = TRUE)
VD &lt;- VD - 1

## Add VD to indicators
indicators &lt;- data.frame(indicators, VD, stringsAsFactors = FALSE)

## Clean-up
rm(VD)
</command>
			<property title="Recode" shape="TRANSFORM"/>
			<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
				<subflow>
					<graph version="0.8" width="920" height="245" locationtype="a" offsetx="100" offsety="41">
						<node id="58" date="1590735853005" uid="81aebffac63ada5e" x="120" y="150">
							<command>## Recode iodine indicators
##   1 = Severe iodine deficiency - non-pregnant non-lactating WRA
##   2 = Moderate iodine deficiency - non-pregnant non-lactating WRA
##   3 = Mild iodine deficiency - non-pregnant non-lactating WRA
##   4 = Iodine insufficiency - pregnant (lactating or not) WRA
##   5 = Iodine insufficiency - lactating non-pregnant WRA
##   6 = Above requirements - any group
##   7 = Excessive - any group
##   8 = Adequate - any group

ID &lt;- with(mnData, {
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 2 &amp; iodine &lt; 20, 1,
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 2 &amp; iodine &gt;= 20 &amp; iodine &lt; 50, 2,
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 2 &amp; iodine &gt;= 50 &amp; iodine &lt; 100, 3,
  ifelse(ageGrp == 2 &amp; pregnant == 1 &amp; iodine &lt; 150, 4,
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 1 &amp; iodine &lt; 100, 5,
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 2 &amp; iodine &gt;= 200 &amp; iodine &lt; 300, 6,
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 2 &amp; iodine &gt;= 300, 7,
  ifelse(ageGrp == 2 &amp; pregnant == 1 &amp; iodine &gt;= 250 &amp; iodine &lt; 500, 6,
  ifelse(ageGrp == 2 &amp; pregnant == 1 &amp; iodine &gt;= 500, 7,
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 2 &amp; iodine &gt;= 100 &amp; iodine &lt; 200, 8,
  ifelse(ageGrp == 2 &amp; pregnant == 1 &amp; iodine &gt;= 150 &amp; iodine &lt; 250, 8,
  ifelse(ageGrp == 2 &amp; pregnant == 2 &amp; lactating == 1 &amp; iodine &gt;= 100, 8, NA))))))))))))
})

## Recode ID into specific indicators

## ID1A: Insufficient iodine in non-pregnant lactating WRA
ID1A &lt;- ifelse(mnData$lactating == 1 &amp; mnData$pregnant == 2 &amp; ID == 5, 1,
          ifelse(mnData$lactating == 1 &amp; mnData$pregnant == 2 &amp; ID != 5, 0, NA))

## Check recode - all values check out
cbind(mnData[ , c(&quot;pregnant&quot;, &quot;lactating&quot;)], ID, ID1A)

## ID1B: Insufficient iodine in pregnant WRA
ID1B &lt;- ifelse(mnData$pregnant == 1 &amp; ID == 4, 1,
	     ifelse(mnData$pregnant == 2 &amp; ID != 4, 0, NA))

## Check recode - all values check out
cbind(mnData[ , c(&quot;pregnant&quot;, &quot;lactating&quot;)], ID, ID1B)

## ID2: Mild iodine deficiency in non-pregnant non-lactating WRA
ID2 &lt;- ifelse(mnData$pregnant == 2 &amp; mnData$lactating == 2 &amp; ID == 3, 1,
         ifelse(mnData$pregnant == 2 &amp; mnData$lactating == 2 &amp; ID != 3, 0, NA))

## Check recode
cbind(mnData[ , c(&quot;pregnant&quot;, &quot;lactating&quot;)], ID, ID2)

## ID3: Moderate iodine deficiency in non-pregnant non-lactating WRA
ID3 &lt;- ifelse(mnData$pregnant == 2 &amp; mnData$lactating == 2 &amp; ID == 2, 1,
	    ifelse(mnData$pregnant == 2 &amp; mnData$lactating == 2 &amp; ID != 2, 0, NA))

## Check recode
cbind(mnData[ , c(&quot;pregnant&quot;, &quot;lactating&quot;)], ID, ID3)

## ID4: Severe iodine deficiency in non-pregnant non-lactating WRA
ID4 &lt;- ifelse(mnData$pregnant == 2 &amp; mnData$lactating == 2 &amp; ID == 1, 1,
	ifelse(mnData$pregnant == 2 &amp; mnData$lactating == 2 &amp; ID != 1, 0, NA))

## Check recode
cbind(mnData[ , c(&quot;pregnant&quot;, &quot;lactating&quot;)], ID, ID4)

## ID5: Above requirements
ID5 &lt;- ifelse(ID == 6, 1, 0)

## check recode
cbind(mnData[ , c(&quot;pregnant&quot;, &quot;lactating&quot;)], ID, ID5)

## ID6: Excessive
ID6 &lt;- ifelse(ID == 7, 1, 0)

## check recode
cbind(mnData[ , c(&quot;pregnant&quot;, &quot;lactating&quot;)], ID, ID6)

## Add to indicators
indicators &lt;- data.frame(indicators, ID, ID1A, ID1B, ID2, ID3, ID4, ID5, ID6, stringsAsFactors = FALSE)

## Clean-up
rm(ID, ID1A, ID1B, ID2, ID3, ID4, ID5, ID6)



</command>
							<property title="Iodine" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="59" date="1590733210079" uid="4f8d17142376c640" x="120" y="70">
							<command>## Recode calcium
##   1 = Hypocalcemia
##   2 = Hypercalcemia
##   3 = Normocalcemia

CA &lt;- with(mnData, {
	ifelse(ageGrp == 1 &amp; childAge %in% 12:60 &amp; calcium &lt; 9.4, 1,
	  ifelse(ageGrp == 2 &amp; calcium &lt; 8.8, 1,
	    ifelse(ageGrp == 1 &amp; childAge %in% 12:60 &amp; calcium &gt; 10.8, 2,
	      ifelse(ageGrp == 2 &amp; calcium &gt; 10, 2,
	        ifelse(ageGrp == 1 &amp; childAge %in% 12:60 &amp; calcium &gt;= 9.4 &amp; calcium &lt;= 10.8, 3,
	          ifelse(ageGrp == 2 &amp; calcium &gt;= 8.8 &amp; calcium &gt;= 10, 3, NA))))))
})

## Check - Randomly checked 10 lines of data - all checks out
cbind(mnData[ , c(&quot;ageGrp&quot;, &quot;childAge&quot;, &quot;calcium&quot;)], CA)

## Recode to hypocalcemia
CA1 &lt;- ifelse(CA == 1, 1, 0)

## Recode to hypercalcemia
CA2 &lt;- ifelse(CA == 2, 1, 0)

## Add to indicators data.frame
indicators &lt;- data.frame(indicators, CA, CA1, CA2, stringsAsFactors = FALSE)

## Clean-up
rm(CA, CA1, CA2)

</command>
							<property title="Calcium" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="60" date="1590700938492" uid="21646fd4fd79af90" x="0" y="160">
							<command>## AI: Acute inflammation indicators
##   1 = Inflammation
##   0 = No inflammation

AI &lt;- findInterval(mnData$crp, vec = c(0, 5, Inf), rightmost.closed = TRUE, left.open = TRUE)
AI &lt;- AI - 1

## Add AI to indicators
indicators &lt;- data.frame(indicators, AI, stringsAsFactors = FALSE)

## Clean-up
rm(AI)</command>
							<property title="CRP" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="61" date="1591264750441" uid="fe88ae3383648681" x="-80" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">in</entry>
							</option>
						</node>
						<node id="62" date="1591268016018" uid="5b1c9f64fb2607f7" x="230" y="0">
							<command>## VA: Retinol (Vitamin A indicators) - assumes retinol is in micromol/L units
##   1 = deficient
##   0 = Not deficient

VA &lt;- findInterval(mnData$retinol, vec = c(0, 0.7, Inf), rightmost.closed = TRUE, left.open = TRUE)
VA &lt;- VA - 1

## Add VA to indicators
indicators &lt;- data.frame(indicators, VA, stringsAsFactors = FALSE)

## Clean-up
rm(VA)</command>
							<property title="Retinol" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="63" date="1591264750441" uid="a357690ff1c0fa40" x="230" y="150">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">out</entry>
							</option>
						</node>
						<node id="64" date="1590669186353" uid="56dc4623f894f14d" x="0" y="70">
							<command>## Recode anaemia indicators ###################################
##   1 = Severe anaemia
##   2 = Moderate anaemaia
##   3 = Mild anaemia
##   4 = No anaemia

## AN: Anaemia status
AN &lt;- NA

## under 5 children
AN[mnData$ageGrp == 1] &lt;- recode_hb_u5(x = mnData[mnData$ageGr == 1, ], factor = 10)
                                          
## non-pregnant WRA
AN[mnData$ageGrp == 2 &amp; mnData$pregnant == 2] &lt;- recode_hb_wra(x = mnData[mnData$ageGrp == 2 &amp; mnData$pregnant == 2, ], factor = 10)
   
## pregnant WRA
AN[mnData$ageGrp == 2 &amp; mnData$pregnant == 1] &lt;- recode_hb_pregnant(x = mnData[mnData$ageGrp == 2 &amp; mnData$pregnant == 1, ], factor = 10)

## AN1: Mild anaemia
AN1 &lt;- recode(var = AN, recodes = &quot;1:2=0;3=1;4=0&quot;)                                                                                     
## AN2: Moderate anaemia
AN2 &lt;- recode(var = AN, recodes = &quot;1=0;2=1;3:4=0&quot;)

## AN3: Severe anaemia
AN3 &lt;- recode(var = AN, recodes = &quot;1=1;2:4=0&quot;)

## AN0: Any anaemia
AN0 &lt;- ifelse(AN1 == 1 | AN2 == 1 | AN3 == 1, 1, 0)

## Concatenate recoded indicators into indicators data.frame
indicators &lt;- data.frame(indicators, AN, AN1, AN2, AN3, AN0, stringsAsFactors = FALSE)

rm(AN, AN1, AN2, AN3, AN0)
                                                                                                                           






</command>
							<property title="Anaemia" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="65" date="1590701462549" uid="306ee55cb0087e89" x="120" y="0">
							<command>## Recode iron stores indicators
##   1 = Iron deficiency
##   2 = Normal iron levels
##   3 = Iron overload

IR &lt;- with(mnData, {
	ifelse(ageGrp == 1 &amp; crp &gt; 5 &amp; (ferritin * 0.65) &lt; 12, 1,
	  ifelse(ageGrp == 1 &amp; crp &lt;= 5 &amp; ferritin &lt; 12, 1,
	    ifelse(ageGrp == 2 &amp; crp &gt; 5 &amp; (ferritin * 0.65) &lt; 15, 1,
	      ifelse(ageGrp == 2 &amp; crp &lt;= 5 &amp; ferritin &lt; 15, 1,
	        ifelse(ageGrp == 2 &amp; crp &gt; 5 &amp; (ferritin * 0.65) &gt; 150, 3,
	          ifelse(ageGrp == 2 &amp; crp &lt; 5 &amp; ferritin &gt; 150, 3, 2))))))
})


## IR1: Iron deficiency
IR1 &lt;- recode(var = IR, recodes = &quot;1=1;2=0&quot;)

## IR2: Iron overload
IR2 &lt;- ifelse(mnData$ageGrp == 2 &amp; IR == 3, 1,
         ifelse(mnData$ageGrp == 2 &amp; IR != 3, 0, NA))
         
## IDA: iron-deficiency anaemia
IDA &lt;- ifelse(IR == 1 &amp; indicators$AN != 4, 1, 0)


## Add IR indicators to indicators data.frame
indicators &lt;- data.frame(indicators, IR, IR1, IR2, IDA, stringsAsFactors = FALSE)

## clean-up
rm(IR, IR1, IR2, IDA)</command>
							<property title="Ferritin" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="66" date="1590699906987" uid="fce58d5074d68525" x="0" y="0">
							<command>## Add elevation data to mnData
mnData &lt;- merge(psuData[ , c(&quot;psu&quot;, &quot;longitude&quot;, &quot;latitude&quot;)], mnData, by = &quot;psu&quot;, all.y = TRUE)

sudanAlt_subset &lt;- intersect(sudanSRTM, sudan01)
sudanAlt_subset &lt;- mask(sudanAlt_subset, sudan01)

mnData_spdf &lt;- SpatialPointsDataFrame(coords = mnData[ , c(&quot;longitude&quot;, &quot;latitude&quot;)], 
	data = mnData,
	proj4string = CRS(proj4string(sudan01)))

## Get corresponding altitude from SRTM data
altitude &lt;- extract(sudanAlt_subset, mnData_spdf)

## Add altitude to mnData
mnData &lt;- data.frame(mnData, altitude, stringsAsFactors = FALSE)

## Adjust hb based on altitude
adjHb &lt;- with(mnData, {
	ifelse(altitude &gt;= 1000 &amp; altitude &lt; 1500, hb - 2,
	  ifelse(altitude &gt;= 1500 &amp; altitude &lt; 2000, hb - 5,
	    ifelse(altitude &gt;= 2000 &amp; altitude &lt; 2500, hb - 8,
	      ifelse(altitude &gt;= 2500 &amp; altitude &lt; 3000, hb - 13,
	        ifelse(altitude &gt;= 3000 &amp; altitude &lt; 3500, hb - 19,
	          ifelse(altitude &gt;= 3500 &amp; altitude &lt; 4000, hb - 27,
	            ifelse(altitude &gt;= 4000 &amp; altitude &lt; 4500, hb - 35,
	             ifelse(altitude &gt;= 4500, hb - 45, hb))))))))
})

## Adjust ferritin based on crp value
adjFerritin &lt;- with(mnData, {
	ifelse(crp &gt; 5, ferritin * 0.65, ferritin)
})

## Add to mnData
mnData &lt;- data.frame(mnData, adjHb, adjFerritin, stringsAsFactors = FALSE)

## Create indicators concatenating data.frame
indicators &lt;- mnData[ , c(&quot;stateID&quot;, &quot;localityID&quot;, &quot;psu&quot;, &quot;longitude&quot;, &quot;latitude&quot;, 
                          &quot;ageGrp&quot;, &quot;pregnant&quot;, &quot;lactating&quot;, &quot;plw&quot;,
                          &quot;hb&quot;, &quot;adjHb&quot;, &quot;ferritin&quot;, &quot;adjFerritin&quot;, 
                          &quot;crp&quot;, &quot;calcium&quot;, &quot;iodine&quot;, &quot;retinol&quot;, &quot;vitd&quot;)]

## Clean-up
rm(sudanAlt_subset, mnData_spdf, altitude, adjHb, adjFerritin)
</command>
							<property title="Structure data" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="67" date="1591268137026" uid="424d01296db2e8a4" x="230" y="70">
							<command>## VD: Vitamin D - assumes vitamin D is in nanomol/L units
##   1 = deficient
##   0 = Not deficient

VD &lt;- findInterval(mnData$vitd, vec = c(0, 25, Inf), rightmost.closed = TRUE, left.open = TRUE)
VD &lt;- VD - 1

## Add VD to indicators
indicators &lt;- data.frame(indicators, VD, stringsAsFactors = FALSE)

## Clean-up
rm(VD)</command>
							<property title="Vitamin D" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<edge from="65" to="59"/>
						<edge from="61" to="66"/>
						<edge from="58" to="62"/>
						<edge from="62" to="67"/>
						<edge from="59" to="58"/>
						<edge from="60" to="65"/>
						<edge from="67" to="63"/>
						<edge from="66" to="64"/>
						<edge from="64" to="60"/>
					</graph>
				</subflow>
			</option>
		</node>
		<node id="68" date="1591267132744" uid="b58ce6128ae9ada2" x="400" y="400">
			<command>## Concatenate allResults from the various sets

load(&quot;resultsSet1.Rdata&quot;)
stateResults &lt;- allResults

load(&quot;resultsSet2.Rdata&quot;)
stateResults &lt;- rbind(stateResults, allResults)

load(&quot;resultsSet3.Rdata&quot;)
stateResults &lt;- rbind(stateResults, allResults)

load(&quot;resultsSet4.Rdata&quot;)
stateResults &lt;- rbind(stateResults, allResults)

load(&quot;resultsSet5.Rdata&quot;)
stateResults &lt;- rbind(stateResults, allResults)

load(&quot;resultsSet6.Rdata&quot;)
stateResults &lt;- rbind(stateResults, allResults)

##
write.csv(stateResults, &quot;_byStatesMNresults.csv&quot;, row.names = FALSE)

results &lt;- openxlsx::createWorkbook()

## Save per state result into a worksheet in a single workbook
for(i in unique(stateResults$State)) {
  currentStateResults &lt;- subset(stateResults,
                                State == i,
                                select = c(-State, -sd))
  
  currentStateResults[!stringr::str_detect(currentStateResults$Indicator, &quot;Median&quot;), c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;)] &lt;- round(currentStateResults[!stringr::str_detect(currentStateResults$Indicator, &quot;Median&quot;), c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;)] * 100, digits = 2)
  currentStateResults[stringr::str_detect(currentStateResults$Indicator, &quot;Median&quot;), c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;)] &lt;- round(currentStateResults[stringr::str_detect(currentStateResults$Indicator, &quot;Median&quot;), c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;)], digits = 2)
  
  openxlsx::addWorksheet(wb = results, sheetName = i)
  openxlsx::writeData(wb = results, 
                      sheet = i, 
                      currentStateResults)
}

openxlsx::saveWorkbook(wb = results, file = &quot;_byStates.xlsx&quot;, overwrite = TRUE)


</command>
			<property title="Combine Sets" shape="TRANSFORM"/>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<node id="69" date="1591266970776" uid="8c970222b4544eae" x="250" y="330">
			<command>## Select states to bootstrap
STATES &lt;- c(4, 10, 16)

## Bootstrap anaemia indicators ################################################
  
## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)
  
## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))
  
## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])
  
## indicator name vector
params &lt;- c(&quot;adjHb&quot;, &quot;AN0&quot;, &quot;AN1&quot;, &quot;AN2&quot;, &quot;AN3&quot;)
  
## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(STATES) * 3, 
                            byrow = TRUE))
  
bootDFnames &lt;- NULL
  
for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}
  
## rename bootDF
names(bootDF) &lt;- bootDFnames
  
## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}
  
## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)
  
## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)
  
## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)
  
## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AN0&quot;, &quot;Any anaemia&quot;, 
                        ifelse(yy[ , 3] == &quot;AN1&quot;, &quot;Mild anaemia&quot;,
                        ifelse(yy[ , 3] == &quot;AN2&quot;, &quot;Moderate anaemia&quot;, 
                               ifelse(yy[ , 3] == &quot;AN3&quot;, &quot;Severe anaemia&quot;, 
                                      &quot;Median adjusted serum haemoglobin concentration (g/dL)&quot;))))

anaemiaResults4 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)

## Bootstrap calcium indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;calcium&quot;, &quot;CA1&quot;, &quot;CA2&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), 
                                                 bootMedian, 
                                                 bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;CA1&quot;, &quot;Hypocalcaemia&quot;,
                        ifelse(yy[ , 3] == &quot;CA2&quot;, &quot;Hypercalcaemia&quot;, 
                               &quot;Median serum calcium concentration (mg/dL)&quot;))

calciumResults4 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;crp&quot;, &quot;AI&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AI&quot;, &quot;Acute inflammation&quot;, 
                               &quot;Median serum c-reactive protein concentration (mg/L)&quot;)

inflammationResults4 &lt;- data.frame(State = yy[ , 1],
                                   Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                                   xx,
                                   row.names = NULL,
                                   stringsAsFactors = FALSE)

## Bootstrap anaemia indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- with(subDF, {
  ifelse(pregnant == 1, &quot;Pregnant&quot;,
    ifelse(pregnant == 2 &amp; lactating == 2, &quot;Non-pregnant non-lactating&quot;,
      ifelse(pregnant == 2 &amp; lactating == 1, &quot;Non-pregnant lactating&quot;, NA)))
})

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;iodine&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

iodineResults4 &lt;- data.frame(State = yy[ , 1],
                             Indicator = paste(yy[ , 2], &quot;Median urinary iodine concentration (microgram/L)&quot;, sep = &quot;: &quot;),
                             xx,
                             row.names = NULL,
                             stringsAsFactors = FALSE)

## Bootstrap iron indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;IR1&quot;, &quot;IR2&quot;, &quot;IDA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(locNames$locality[locNames$stateID %in% STATES]) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in unique(locNames$locality[locNames$state == i])) {
    for(k in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
      for(l in params) {
        bootDFnames &lt;- c(bootDFnames, paste(i, j, k, l, sep = &quot;_&quot;))
      }
    }
  }
}

names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$localityID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$localityID == i])
  ## Get current locality name
  currentLocalityName &lt;- unique(locNames$locality[locNames$localityID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, localityID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      cat(&quot;\n&quot;, 
          currentStateName, &quot; - &quot;, 
          currentLocalityName, &quot; - &quot;, 
          j, &quot; - &quot;,
          k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = bootClassic, 
                              params = k,
                              outputColumns = paste(currentStateName,
                                                    currentLocalityName,
                                                    j,
                                                    k,
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, currentLocalityName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename rows
#row.names(xx) &lt;- 1:nrow(xx)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 4] == &quot;IR1&quot;, &quot;Iron deficiency&quot;,
                   ifelse(yy[ , 4] == &quot;IR2&quot;, &quot;Iron overload&quot;, &quot;Iron deficiency anaemia&quot;))

ironResults4 &lt;- data.frame(State = yy[ , 1],
                           Locality = yy[ , 2],
                           Indicator = paste(yy[ , 3], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

ironResults4 &lt;- ironResults4[ironResults4$Indicator != &quot;Child: Iron overload&quot;, ]

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;retinol&quot;, &quot;VA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VA&quot;, &quot;Vitamin A deficiency&quot;, 
                               &quot;Median serum retinol concentration (mg/L)&quot;)

retinolResults4 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;vitd&quot;, &quot;VD&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VD&quot;, &quot;Vitamin D deficiency&quot;, 
                               &quot;Median serum 25-hydroxyvitamin D3 concentration (mg/L)&quot;)

vitdResults4 &lt;- data.frame(State = yy[ , 1],
                           Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

## Combine all
allResults4 &lt;- data.frame(
  rbind(anaemiaResults4, inflammationResults4, ironResults4,
        calciumResults4, iodineResults4, retinolResults4, vitdResults4), stringsAsFactors = FALSE
)

## Save
save(allResults4, file = &quot;resultsSet4.Rdata&quot;)

## Clean-up
rm(allResults4, anaemiaResults4, inflammationResults4, ironResults4, calciumResults4, iodineResults4, retinolResults4, vitdResults4)

</command>
			<property title="Bootstrap Set 4" shape="MODEL"/>
			<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
				<subflow>
					<graph version="0.8" width="920" height="245" locationtype="a" offsetx="100" offsety="41">
						<node id="70" date="1591269078056" uid="97433ba1b9e35fdf" x="410" y="0">
							<command>## Combine all
allResults4 &lt;- data.frame(
  rbind(anaemiaResults4, inflammationResults4, ironResults4,
        calciumResults4, iodineResults4, retinolResults4, vitdResults4), stringsAsFactors = FALSE
)

## Save
save(allResults4, file = &quot;resultsSet4.Rdata&quot;)

## Clean-up
rm(allResults4, anaemiaResults4, inflammationResults4, ironResults4, calciumResults4, iodineResults4, retinolResults4, vitdResults4)

</command>
							<property title="Combine results" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="71" date="1591266428191" uid="197ce82db4262fbf" x="90" y="0">
							<command>## Bootstrap anaemia indicators ################################################
  
## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)
  
## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))
  
## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])
  
## indicator name vector
params &lt;- c(&quot;adjHb&quot;, &quot;AN0&quot;, &quot;AN1&quot;, &quot;AN2&quot;, &quot;AN3&quot;)
  
## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(STATES) * 3, 
                            byrow = TRUE))
  
bootDFnames &lt;- NULL
  
for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}
  
## rename bootDF
names(bootDF) &lt;- bootDFnames
  
## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}
  
## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)
  
## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)
  
## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)
  
## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AN0&quot;, &quot;Any anaemia&quot;, 
                        ifelse(yy[ , 3] == &quot;AN1&quot;, &quot;Mild anaemia&quot;,
                        ifelse(yy[ , 3] == &quot;AN2&quot;, &quot;Moderate anaemia&quot;, 
                               ifelse(yy[ , 3] == &quot;AN3&quot;, &quot;Severe anaemia&quot;, 
                                      &quot;Median adjusted serum haemoglobin concentration (g/dL)&quot;))))

anaemiaResults4 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)
</command>
							<property title="Anaemia" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="72" date="1591269078049" uid="c29cc3f32861aa61" x="250" y="80">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;retinol&quot;, &quot;VA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VA&quot;, &quot;Vitamin A deficiency&quot;, 
                               &quot;Median serum retinol concentration (mg/L)&quot;)

retinolResults4 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)
</command>
							<property title="Retinol" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="73" date="1591266428142" uid="77c376829bf920b6" x="90" y="80">
							<command>## Bootstrap calcium indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;calcium&quot;, &quot;CA1&quot;, &quot;CA2&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), 
                                                 bootMedian, 
                                                 bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;CA1&quot;, &quot;Hypocalcaemia&quot;,
                        ifelse(yy[ , 3] == &quot;CA2&quot;, &quot;Hypercalcaemia&quot;, 
                               &quot;Median serum calcium concentration (mg/dL)&quot;))

calciumResults4 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)
</command>
							<property title="Calcium" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="74" date="1591266428085" uid="1b34f817e0285838" x="250" y="0">
							<command>## Bootstrap iron indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;IR1&quot;, &quot;IR2&quot;, &quot;IDA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(locNames$locality[locNames$stateID %in% STATES]) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in unique(locNames$locality[locNames$state == i])) {
    for(k in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
      for(l in params) {
        bootDFnames &lt;- c(bootDFnames, paste(i, j, k, l, sep = &quot;_&quot;))
      }
    }
  }
}

names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$localityID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$localityID == i])
  ## Get current locality name
  currentLocalityName &lt;- unique(locNames$locality[locNames$localityID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, localityID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      cat(&quot;\n&quot;, 
          currentStateName, &quot; - &quot;, 
          currentLocalityName, &quot; - &quot;, 
          j, &quot; - &quot;,
          k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = bootClassic, 
                              params = k,
                              outputColumns = paste(currentStateName,
                                                    currentLocalityName,
                                                    j,
                                                    k,
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, currentLocalityName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename rows
#row.names(xx) &lt;- 1:nrow(xx)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 4] == &quot;IR1&quot;, &quot;Iron deficiency&quot;,
                   ifelse(yy[ , 4] == &quot;IR2&quot;, &quot;Iron overload&quot;, &quot;Iron deficiency anaemia&quot;))

ironResults4 &lt;- data.frame(State = yy[ , 1],
                           Locality = yy[ , 2],
                           Indicator = paste(yy[ , 3], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

ironResults4 &lt;- ironResults4[ironResults4$Indicator != &quot;Child: Iron overload&quot;, ]
</command>
							<property title="Iron" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="75" date="1591266970775" uid="29cadcf33e12d3dd" x="-80" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">in</entry>
							</option>
						</node>
						<node id="76" date="1591269078060" uid="ba224152e0d49c96" x="330" y="0">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;vitd&quot;, &quot;VD&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VD&quot;, &quot;Vitamin D deficiency&quot;, 
                               &quot;Median serum 25-hydroxyvitamin D3 concentration (mg/L)&quot;)

vitdResults4 &lt;- data.frame(State = yy[ , 1],
                           Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)
</command>
							<property title="Vitamin D" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="77" date="1591266428258" uid="9ddf74f734056cd7" x="170" y="80">
							<command>## Bootstrap anaemia indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- with(subDF, {
  ifelse(pregnant == 1, &quot;Pregnant&quot;,
    ifelse(pregnant == 2 &amp; lactating == 2, &quot;Non-pregnant non-lactating&quot;,
      ifelse(pregnant == 2 &amp; lactating == 1, &quot;Non-pregnant lactating&quot;, NA)))
})

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;iodine&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

iodineResults4 &lt;- data.frame(State = yy[ , 1],
                             Indicator = paste(yy[ , 2], &quot;Median urinary iodine concentration (microgram/L)&quot;, sep = &quot;: &quot;),
                             xx,
                             row.names = NULL,
                             stringsAsFactors = FALSE)
</command>
							<property title="Iodine" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="78" date="1591266428078" uid="95616db13cb0f31b" x="170" y="0">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;crp&quot;, &quot;AI&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AI&quot;, &quot;Acute inflammation&quot;, 
                               &quot;Median serum c-reactive protein concentration (mg/L)&quot;)

inflammationResults4 &lt;- data.frame(State = yy[ , 1],
                                   Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                                   xx,
                                   row.names = NULL,
                                   stringsAsFactors = FALSE)
</command>
							<property title="Inflammation" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="79" date="1591266428202" uid="c3257e748ac85c04" x="0" y="0">
							<command>## Select states to bootstrap
STATES &lt;- c(4, 10, 16)</command>
							<property title="Setup Set 4" shape="INPUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="80" date="1591266970775" uid="1eaa862d5a0a2efe" x="490" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">out</entry>
							</option>
						</node>
						<edge from="73" to="78"/>
						<edge from="78" to="77"/>
						<edge from="71" to="73"/>
						<edge from="76" to="70"/>
						<edge from="77" to="74"/>
						<edge from="72" to="76"/>
						<edge from="75" to="79"/>
						<edge from="79" to="71"/>
						<edge from="74" to="72"/>
						<edge from="70" to="80"/>
					</graph>
				</subflow>
			</option>
		</node>
		<node id="81" date="1591266919452" uid="19a535fb2e8d5350" x="150" y="400">
			<command>## Select states to bootstrap
STATES &lt;- c(2, 8, 14)

## Bootstrap anaemia indicators ################################################
  
## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)
  
## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))
  
## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])
  
## indicator name vector
params &lt;- c(&quot;adjHb&quot;, &quot;AN0&quot;, &quot;AN1&quot;, &quot;AN2&quot;, &quot;AN3&quot;)
  
## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(STATES) * 3, 
                            byrow = TRUE))
  
bootDFnames &lt;- NULL
  
for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}
  
## rename bootDF
names(bootDF) &lt;- bootDFnames
  
## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}
  
## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)
  
## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)
  
## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)
  
## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AN0&quot;, &quot;Any anaemia&quot;, 
                        ifelse(yy[ , 3] == &quot;AN1&quot;, &quot;Mild anaemia&quot;,
                        ifelse(yy[ , 3] == &quot;AN2&quot;, &quot;Moderate anaemia&quot;, 
                               ifelse(yy[ , 3] == &quot;AN3&quot;, &quot;Severe anaemia&quot;, 
                                      &quot;Median adjusted serum haemoglobin concentration (g/dL)&quot;))))

anaemiaResults2 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)

## Bootstrap calcium indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;calcium&quot;, &quot;CA1&quot;, &quot;CA2&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), 
                                                 bootMedian, 
                                                 bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;CA1&quot;, &quot;Hypocalcaemia&quot;,
                        ifelse(yy[ , 3] == &quot;CA2&quot;, &quot;Hypercalcaemia&quot;, 
                               &quot;Median serum calcium concentration (mg/dL)&quot;))

calciumResults2  &lt;- data.frame(State = yy[ , 1],
                               Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                               xx,
                               row.names = NULL,
                               stringsAsFactors = FALSE)

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;crp&quot;, &quot;AI&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AI&quot;, &quot;Acute inflammation&quot;, 
                               &quot;Median serum c-reactive protein concentration (mg/L)&quot;)

inflammationResults2 &lt;- data.frame(State = yy[ , 1],
                                   Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                                   xx,
                                   row.names = NULL,
                                   stringsAsFactors = FALSE)

## Bootstrap anaemia indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- with(subDF, {
  ifelse(pregnant == 1, &quot;Pregnant&quot;,
    ifelse(pregnant == 2 &amp; lactating == 2, &quot;Non-pregnant non-lactating&quot;,
      ifelse(pregnant == 2 &amp; lactating == 1, &quot;Non-pregnant lactating&quot;, NA)))
})

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;iodine&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

iodineResults2 &lt;- data.frame(State = yy[ , 1],
                             Indicator = paste(yy[ , 2], &quot;Median urinary iodine concentration (microgram/L)&quot;, sep = &quot;: &quot;),
                             xx,
                             row.names = NULL,
                             stringsAsFactors = FALSE)

## Bootstrap iron indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;IR1&quot;, &quot;IR2&quot;, &quot;IDA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(locNames$locality[locNames$stateID %in% STATES]) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in unique(locNames$locality[locNames$state == i])) {
    for(k in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
      for(l in params) {
        bootDFnames &lt;- c(bootDFnames, paste(i, j, k, l, sep = &quot;_&quot;))
      }
    }
  }
}

names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$localityID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$localityID == i])
  ## Get current locality name
  currentLocalityName &lt;- unique(locNames$locality[locNames$localityID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, localityID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      cat(&quot;\n&quot;, 
          currentStateName, &quot; - &quot;, 
          currentLocalityName, &quot; - &quot;, 
          j, &quot; - &quot;,
          k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = bootClassic, 
                              params = k,
                              outputColumns = paste(currentStateName,
                                                    currentLocalityName,
                                                    j,
                                                    k,
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, currentLocalityName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename rows
#row.names(xx) &lt;- 1:nrow(xx)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 4] == &quot;IR1&quot;, &quot;Iron deficiency&quot;,
                   ifelse(yy[ , 4] == &quot;IR2&quot;, &quot;Iron overload&quot;, &quot;Iron deficiency anaemia&quot;))

ironResults2 &lt;- data.frame(State = yy[ , 1],
                           Locality = yy[ , 2],
                           Indicator = paste(yy[ , 3], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

ironResults2 &lt;- ironResults2[ironResults2$Indicator != &quot;Child: Iron overload&quot;, ]

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;retinol&quot;, &quot;VA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VA&quot;, &quot;Vitamin A deficiency&quot;, 
                               &quot;Median serum retinol concentration (mg/L)&quot;)

retinolResults2 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)

## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;vitd&quot;, &quot;VD&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VD&quot;, &quot;Vitamin D deficiency&quot;, 
                               &quot;Median serum 25-hydroxyvitamin D3 concentration (mg/L)&quot;)

vitdResults2 &lt;- data.frame(State = yy[ , 1],
                           Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

## Combine all
allResults2 &lt;- data.frame(
  rbind(anaemiaResults2, inflammationResults2, ironResults2,
        calciumResults2, iodineResults2, retinolResults2, vitdResults2), stringsAsFactors = FALSE
)

## Save
save(allResults2, file = &quot;resultsSet2.Rdata&quot;)

## Clean-up
rm(allResults2, anaemiaResults2, inflammationResults2, ironResults2, calciumResults2, iodineResults2, retinolResults2, vitdResults2)

</command>
			<property title="Bootstrap Set 2" shape="MODEL"/>
			<option type="com.ef_prime.rflow.node.base.SubflowNodeModel">
				<subflow>
					<graph version="0.8" width="920" height="245" locationtype="a" offsetx="100" offsety="41">
						<node id="82" date="1591265995616" uid="3754ee4c3aa98c9e" x="90" y="0">
							<command>## Bootstrap anaemia indicators ################################################
  
## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)
  
## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))
  
## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])
  
## indicator name vector
params &lt;- c(&quot;adjHb&quot;, &quot;AN0&quot;, &quot;AN1&quot;, &quot;AN2&quot;, &quot;AN3&quot;)
  
## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(STATES) * 3, 
                            byrow = TRUE))
  
bootDFnames &lt;- NULL
  
for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}
  
## rename bootDF
names(bootDF) &lt;- bootDFnames
  
## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}
  
## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)
  
## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)
  
## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)
  
## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AN0&quot;, &quot;Any anaemia&quot;, 
                        ifelse(yy[ , 3] == &quot;AN1&quot;, &quot;Mild anaemia&quot;,
                        ifelse(yy[ , 3] == &quot;AN2&quot;, &quot;Moderate anaemia&quot;, 
                               ifelse(yy[ , 3] == &quot;AN3&quot;, &quot;Severe anaemia&quot;, 
                                      &quot;Median adjusted serum haemoglobin concentration (g/dL)&quot;))))

anaemiaResults2 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)
</command>
							<property title="Anaemia" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="83" date="1591268758788" uid="9b767ce0576a6210" x="410" y="0">
							<command>## Combine all
allResults2 &lt;- data.frame(
  rbind(anaemiaResults2, inflammationResults2, ironResults2,
        calciumResults2, iodineResults2, retinolResults2, vitdResults2), stringsAsFactors = FALSE
)

## Save
save(allResults2, file = &quot;resultsSet2.Rdata&quot;)

## Clean-up
rm(allResults2, anaemiaResults2, inflammationResults2, ironResults2, calciumResults2, iodineResults2, retinolResults2, vitdResults2)

</command>
							<property title="Combine results" shape="TRANSFORM"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="84" date="1591268758797" uid="b40530009b6965eb" x="250" y="70">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;retinol&quot;, &quot;VA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VA&quot;, &quot;Vitamin A deficiency&quot;, 
                               &quot;Median serum retinol concentration (mg/L)&quot;)

retinolResults2 &lt;- data.frame(State = yy[ , 1],
                              Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                              xx,
                              row.names = NULL,
                              stringsAsFactors = FALSE)
</command>
							<property title="Retinol" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="85" date="1591265995583" uid="55595a7f991c91d5" x="170" y="70">
							<command>## Bootstrap anaemia indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- with(subDF, {
  ifelse(pregnant == 1, &quot;Pregnant&quot;,
    ifelse(pregnant == 2 &amp; lactating == 2, &quot;Non-pregnant non-lactating&quot;,
      ifelse(pregnant == 2 &amp; lactating == 1, &quot;Non-pregnant lactating&quot;, NA)))
})

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;iodine&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Pregnant&quot;, &quot;Non-pregnant non-lactating&quot;, &quot;Non-pregnant lactating&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

iodineResults2 &lt;- data.frame(State = yy[ , 1],
                             Indicator = paste(yy[ , 2], &quot;Median urinary iodine concentration (microgram/L)&quot;, sep = &quot;: &quot;),
                             xx,
                             row.names = NULL,
                             stringsAsFactors = FALSE)
</command>
							<property title="Iodine" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="86" date="1591268758792" uid="7e83d5ba3b6f8260" x="330" y="0">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;vitd&quot;, &quot;VD&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;,
                                                          &quot;retinol&quot;,
                                                          &quot;vitd&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;VD&quot;, &quot;Vitamin D deficiency&quot;, 
                               &quot;Median serum 25-hydroxyvitamin D3 concentration (mg/L)&quot;)

vitdResults2 &lt;- data.frame(State = yy[ , 1],
                           Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)
</command>
							<property title="Vitamin D" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="87" date="1591266919452" uid="87d95627698e1fc7" x="-80" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">in</entry>
							</option>
						</node>
						<node id="88" date="1591265995612" uid="8062e928b8284e8b" x="0" y="0">
							<command>## Select states to bootstrap
STATES &lt;- c(2, 8, 14)</command>
							<property title="Setup Set 2" shape="INPUT"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="89" date="1591265995603" uid="2cda06e64189d04e" x="90" y="70">
							<command>## Bootstrap calcium indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;calcium&quot;, &quot;CA1&quot;, &quot;CA2&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), 
                                                 bootMedian, 
                                                 bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;CA1&quot;, &quot;Hypocalcaemia&quot;,
                        ifelse(yy[ , 3] == &quot;CA2&quot;, &quot;Hypercalcaemia&quot;, 
                               &quot;Median serum calcium concentration (mg/dL)&quot;))

calciumResults2  &lt;- data.frame(State = yy[ , 1],
                               Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                               xx,
                               row.names = NULL,
                               stringsAsFactors = FALSE)
</command>
							<property title="Calcium" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="90" date="1591265995595" uid="33605e03afffd2" x="170" y="0">
							<command>## Bootstrap inflammation indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;crp&quot;, &quot;AI&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(stateNames) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    for(k in params) {
      bootDFnames &lt;- c(bootDFnames, paste(i, j, k, sep = &quot;_&quot;))
    }
  }
}

## rename bootDF
names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$stateID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$stateID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, stateID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      ##
      cat(&quot;\n&quot;, currentStateName, &quot; - &quot;, j, &quot; - &quot;, k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = ifelse(k %in% c(&quot;adjHb&quot;, 
                                                          &quot;adjFerritin&quot;, 
                                                          &quot;crp&quot;, 
                                                          &quot;calcium&quot;, 
                                                          &quot;iodine&quot;), bootMedian, bootClassic), 
                              params = k,
                              outputColumns = paste(currentStateName, 
                                                    j,
                                                    k, 
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

## Get robust SD
bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 3] == &quot;AI&quot;, &quot;Acute inflammation&quot;, 
                               &quot;Median serum c-reactive protein concentration (mg/L)&quot;)

inflammationResults2 &lt;- data.frame(State = yy[ , 1],
                                   Indicator = paste(yy[ , 2], indicatorName, sep = &quot;: &quot;),
                                   xx,
                                   row.names = NULL,
                                   stringsAsFactors = FALSE)
</command>
							<property title="Inflammation" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="91" date="1591265995590" uid="b15b1ff88ddf3bf6" x="250" y="0">
							<command>## Bootstrap iron indicators ################################################

## Subset indicators to 3 states data
subDF &lt;- subset(indicators, stateID %in% STATES)

## Create anaemia indicator groups
subDF$indicatorGroup &lt;- ifelse(subDF$ageGrp == 1, &quot;Child&quot;,
                               ifelse(subDF$pregnant == 1, &quot;Pregnant&quot;,
                                      ifelse(subDF$pregnant == 2, &quot;Non-pregnant&quot;, NA)))

## Get state names
stateNames &lt;- unique(locNames$state[locNames$stateID %in% STATES])

## indicator name vector
params &lt;- c(&quot;IR1&quot;, &quot;IR2&quot;, &quot;IDA&quot;)

## Create empty data.frame for concatenating boot results
bootDF &lt;- data.frame(matrix(nrow = REPLICATES, 
                            ncol = length(params) * length(locNames$locality[locNames$stateID %in% STATES]) * 3, 
                            byrow = TRUE))

bootDFnames &lt;- NULL

for(i in stateNames) {
  for(j in unique(locNames$locality[locNames$state == i])) {
    for(k in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
      for(l in params) {
        bootDFnames &lt;- c(bootDFnames, paste(i, j, k, l, sep = &quot;_&quot;))
      }
    }
  }
}

names(bootDF) &lt;- bootDFnames

## Cycle through states
for(i in sort(unique(subDF$localityID))) {
  ## Get current state name
  currentStateName &lt;- unique(locNames$state[locNames$localityID == i])
  ## Get current locality name
  currentLocalityName &lt;- unique(locNames$locality[locNames$localityID == i])
  ## Cycle through grouping categrories
  for(j in c(&quot;Child&quot;, &quot;Pregnant&quot;, &quot;Non-pregnant&quot;)) {
    ## Subset to current grouping category
    currentGroup &lt;- subset(subDF, localityID == i &amp; indicatorGroup == j)
    ## Cycle through indicators
    for(k in params) {
      cat(&quot;\n&quot;, 
          currentStateName, &quot; - &quot;, 
          currentLocalityName, &quot; - &quot;, 
          j, &quot; - &quot;,
          k, &quot;\n\n&quot;, sep = &quot;&quot;); flush.console()
      ## Create empty concatenating vector for current bootstrap outputs
      currentBoot &lt;- NA
      ## Check if current group is not empty and then bootstrap
      if(nrow(currentGroup) &gt; 0) {
        ## Boot
        currentBoot &lt;- bootBW(x = currentGroup, 
                              w = psuData[psuData$psu %in% currentGroup$psu, ],
                              statistic = bootClassic, 
                              params = k,
                              outputColumns = paste(currentStateName,
                                                    currentLocalityName,
                                                    j,
                                                    k,
                                                    sep = &quot;_&quot;),
                              replicates = REPLICATES)
      }
      bootDF[[paste(currentStateName, currentLocalityName, j, k, sep = &quot;_&quot;)]] &lt;- currentBoot
    }
  }
}

## Get estimates and CIs
bootResults &lt;- apply(X = bootDF, MARGIN = 2, 
                     FUN = quantile, 
                     probs = c(0.5, 0.025, 0.975), 
                     na.rm = TRUE)

bootSD &lt;- apply(X = bootDF, MARGIN = 2, FUN = robustSD)

## Convert output to long form
xx &lt;- data.frame(t(bootResults), bootSD)

## Rename rows
#row.names(xx) &lt;- 1:nrow(xx)

## Rename results
names(xx) &lt;- c(&quot;estimate&quot;, &quot;lcl&quot;, &quot;ucl&quot;, &quot;sd&quot;)

## Get admin and identifying data
yy &lt;- stringr::str_split(string = row.names(xx), pattern = &quot;_&quot;, simplify = TRUE)

indicatorName &lt;- ifelse(yy[ , 4] == &quot;IR1&quot;, &quot;Iron deficiency&quot;,
                   ifelse(yy[ , 4] == &quot;IR2&quot;, &quot;Iron overload&quot;, &quot;Iron deficiency anaemia&quot;))

ironResults2 &lt;- data.frame(State = yy[ , 1],
                           Locality = yy[ , 2],
                           Indicator = paste(yy[ , 3], indicatorName, sep = &quot;: &quot;),
                           xx,
                           row.names = NULL,
                           stringsAsFactors = FALSE)

ironResults2 &lt;- ironResults2[ironResults2$Indicator != &quot;Child: Iron overload&quot;, ]
</command>
							<property title="Iron" shape="MODEL"/>
							<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
						</node>
						<node id="92" date="1591266919452" uid="4811d12cfa666d57" x="490" y="0">
							<command></command>
							<property/>
							<option type="com.ef_prime.rflow.node.base.TunnelNodeModel">
								<entry key="io">out</entry>
							</option>
						</node>
						<edge from="89" to="90"/>
						<edge from="83" to="92"/>
						<edge from="91" to="84"/>
						<edge from="85" to="91"/>
						<edge from="90" to="85"/>
						<edge from="82" to="89"/>
						<edge from="86" to="83"/>
						<edge from="88" to="82"/>
						<edge from="87" to="88"/>
						<edge from="84" to="86"/>
					</graph>
				</subflow>
			</option>
		</node>
		<node id="93" date="1590667891107" uid="3ec68feff9156a61" x="150" y="60">
			<command>## bootBW
################################################################################
#
#  Blocking Weighted Bootstrap
#
################################################################################
#
#  Parameters :
#
#    x                A data.frame with PSU in column named &apos;psu&apos;
#
#    w                A data.frame with PSU in column named &apos;psu&apos; and survey
#                     weight (i.e. PSU population) in column named &apos;pop&apos;
#
#    statistic        A function operating on data in &apos;x&apos; (see Example)
#
#    params           Parameters (named columns in &apos;x&apos;) passed to the
#                     function specified in &apos;statistic&apos;
#
#    outputColumns    Names of columns in output data.frame
#
#    replicates       Number of bootstrap replicates (default = 400)
#
################################################################################
#
#  Returns :
#
#    A data.frame with :
#
#      ncol  = length(outputColumns)
#      nrow  = replicates
#      names = outputColumns
#
################################################################################
#
#  Example :
#
#    Example function (estimate a proportion for a binary (0/1) variable) :
#
#      oneP &lt;- function(x, params)
#        {
#        v1 &lt;- params[1]
#        v1Data &lt;- x[[v1]]
#        oneP &lt;- mean(v1Data, na.rm = TRUE)
#        return(oneP)
#        }
#
#  Example call to bootBW function:
#
#    bootP &lt;- bootBW(x = data,
#                    w = pops,
#                    statistic = oneP,
#                    params = &quot;nameOfVariable&quot;,
#                    outputColumns = &quot;p&quot;,
#                    replicates = 400)
#
#  Example estimate with 95% CI :
#
#    quantile(bootP, probs = c(0.500, 0.025, 0.975), na.rm = TRUE)
#
################################################################################
#
#  Version : 16/05/2014
#
################################################################################

bootBW &lt;- function(x, w, statistic, params, outputColumns, replicates = 399)
{
	#
	# Scale and accumulate weights
	#
	w$weight &lt;- w$pop / sum(w$pop)
	w$cumWeight &lt;- cumsum(w$weight)
	#
	# Create data.frame with named columns for output
	#
	boot &lt;- data.frame(matrix(ncol = length(outputColumns), nrow = replicates))
	names(boot) &lt;- outputColumns
	#
	# Create an empty data.frame with same structure of &apos;x&apos; with sufficient rows
	# to hold the largest possible survey replicate (i.e. the number of clusters
	# in &apos;x&apos; multiplied by the size of the largest cluster in &apos;x&apos;)
	#
	nClusters &lt;- nrow(w)
	maxRows &lt;- nClusters * max(table(x$psu))
	emptyDF &lt;- rbind(as.data.frame(lapply(x, function(x) rep.int(NA, maxRows))))
	#
	# Vector to hold clusters to be included in a survey replicate
	#
	sampledClusters &lt;- vector(mode = mode(x$psu), length = nClusters)
	#
	# And now ... resample!
	#
	for(i in 1:replicates)
	{
		#
		# Create a dataframe to hold a survey replicate
		#
		xBW &lt;- emptyDF
		#
		# Blocking Bootstrap from &apos;x&apos; (blocking on x$psu = cluster identifier)
		#
		for(j in 1:nClusters)
		{
			#
			# &quot;Roulette Wheel&quot; algorithm (to select a weighted sample of clusters)
			#
			sampledClusters[j] &lt;- w$psu[which.max(w$cumWeight &gt;= runif(n = 1, min = 0, max = 1))]
		}
		#
		# Pointer for inserting selected clusters into the survey replicate
		#
		rowIndex &lt;- 1
		#
		# Build a (blocking weighted) bootstrap replicate from the selected clusters
		#
		for(k in 1:nClusters)
		{
			#
			# Extract data for cluster and resample within the cluster
			#
			y &lt;- subset(x, psu == sampledClusters[k])
			clusterN &lt;- nrow(y)
			y &lt;- y[sample(1:clusterN, replace = TRUE), ]
			#
			# Insert cluster replicate into survey replicate
			#
			endRow &lt;- rowIndex + clusterN
			xBW[rowIndex:(endRow - 1), ] &lt;- y
			#
			# Update pointer
			#
			rowIndex &lt;- endRow
		}
		#
		# Select data for analysis
		#
		xBW &lt;- xBW[1:(rowIndex - 1), ]
		#
		# Apply statistic
		#
		boot[i, ] &lt;- statistic(xBW, params)
	}
	return(boot)
}

################################################################################
#
#&apos; IQR to detect univariate outliers
#&apos;
#&apos; @param x Numeric vector
#&apos; @param fence \code{IQR} multiplier (defaults to 1.5)
#&apos; @return A logical vector (\code{TRUE} for an outlier)
#&apos; @examples
#&apos; # Use \code{outliersUV()} to detect univariate outliers in an anthropometric
#&apos; # dataset from a SMART survey from Angola (rl.ex01)
#&apos; svy &lt;- rl.ex01
#&apos; svy[outliersUV(svy$muac), ]
#&apos; @export
#&apos;
#
################################################################################

outliersUV &lt;- function(x, fence = 1.5)
{
	iqr &lt;- IQR(x, na.rm = TRUE)
	quartiles &lt;- quantile(x, probs = c(0.25, 0.75), na.rm = TRUE)
	cat(&quot;\nUnivariate outliers : Lower fence = &quot;,
		quartiles[1] - fence * iqr,
		&quot;, Upper fence = &quot;, quartiles[2] + fence * iqr, &quot;\n\n&quot;, sep = &quot;&quot;)
	outliers &lt;- (x &lt; quartiles[1] - fence * iqr) | (x &gt; quartiles[2] + fence * iqr)
	outliers[is.na(outliers)] &lt;- FALSE
	return(outliers)
}

################################################################################
#
# Statistic function (simple proportion) for bootstrap estimation
#
bootClassic &lt;- function(x, params)
{
	result &lt;- vector(mode = &quot;numeric&quot;, length = length(params))
	for(i in 1:length(params))
	{
		result[i]  &lt;- mean(x[[params[i]]], na.rm = TRUE)
	}
	return(result)
}

################################################################################
#
# Statistic function (median) for bootstrap estimation
#
bootMedian &lt;- function(x, params)
{
	result &lt;- vector(mode = &quot;numeric&quot;, length = length(params))
	for(i in 1:length(params))
	{
		result[i]  &lt;- median(x[[params[i]]], na.rm = TRUE)
	}
	return(result)
}


################################################################################
#
# Statistic function (robust SD) 
#
robustSD &lt;- function(x)
{
	robustSD &lt;- IQR(x, na.rm = TRUE) / 1.34898
	##
	return(robustSD)
}</command>
			<property title="Functions"/>
			<option type="com.ef_prime.rflow.node.base.FreeNodeModel"/>
		</node>
		<edge from="55" to="0"/>
		<edge from="28" to="93"/>
		<edge from="0" to="1"/>
		<edge from="4" to="68"/>
		<edge from="56" to="55"/>
		<edge from="81" to="16"/>
		<edge from="29" to="81"/>
		<edge from="42" to="4"/>
		<edge from="68" to="2"/>
		<edge from="3" to="57"/>
		<edge from="41" to="29"/>
		<edge from="69" to="42"/>
		<edge from="57" to="54"/>
		<edge from="16" to="69"/>
	</graph>
	<task>
		<taskgroup>
			<taskproperty/>
			<taskentry node="28">
				<taskproperty>
					<entry key="title">reset</entry>
				</taskproperty>
			</taskentry>
		</taskgroup>
	</task>
</rflow>
